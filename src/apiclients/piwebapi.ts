/**
 * PI Web API 2017 Swagger Spec
 * Swagger Spec file that describes PI Web API
 *
 * OpenAPI spec version: 1.9.0.235
 * Contact: techsupport@osisoft.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');

let defaultBasePath = 'https://devdata.osisoft.com/piwebapi';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class Analysis {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'AnalysisRulePlugInName': string;
    'AutoCreated': boolean;
    'CategoryNames': Array<string>;
    'GroupId': number;
    'HasNotification': boolean;
    'HasTarget': boolean;
    'HasTemplate': boolean;
    'IsConfigured': boolean;
    'IsTimeRuleDefinedByTemplate': boolean;
    'MaximumQueueSize': number;
    'OutputTime': string;
    'Priority': string;
    'PublishResults': boolean;
    'Status': string;
    'TargetWebId': string;
    'TemplateName': string;
    'TimeRulePlugInName': string;
    'Links': AnalysisLinks;
}

export class AnalysisCategory {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'Links': AnalysisCategoryLinks;
}

export class AnalysisCategoryLinks {
    'Self': string;
    'Database': string;
    'Security': string;
    'SecurityEntries': string;
}

export class AnalysisLinks {
    'Self': string;
    'Target': string;
    'Database': string;
    'Categories': string;
    'Template': string;
    'AnalysisRule': string;
    'AnalysisRulePlugIn': string;
    'TimeRule': string;
    'TimeRulePlugIn': string;
    'Security': string;
    'SecurityEntries': string;
}

export class AnalysisRule {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'ConfigString': string;
    'DisplayString': string;
    'EditorType': string;
    'HasChildren': boolean;
    'IsConfigured': boolean;
    'IsInitializing': boolean;
    'PlugInName': string;
    'SupportedBehaviors': Array<string>;
    'VariableMapping': string;
    'Links': AnalysisRuleLinks;
}

export class AnalysisRuleLinks {
    'Self': string;
    'AnalysisRules': string;
    'Analysis': string;
    'AnalysisTemplate': string;
    'Parent': string;
    'PlugIn': string;
}

export class AnalysisRulePlugIn {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'AssemblyFileName': string;
    'AssemblyID': string;
    'AssemblyLoadProperties': Array<string>;
    'AssemblyTime': Date;
    'CompatibilityVersion': number;
    'IsBrowsable': boolean;
    'IsNonEditableConfig': boolean;
    'LoadedAssemblyTime': Date;
    'LoadedVersion': string;
    'Version': string;
    'Links': AnalysisRulePlugInLinks;
}

export class AnalysisRulePlugInLinks {
    'Self': string;
    'AssetServer': string;
}

export class AnalysisTemplate {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'AnalysisRulePlugInName': string;
    'CategoryNames': Array<string>;
    'CreateEnabled': boolean;
    'GroupId': number;
    'HasNotificationTemplate': boolean;
    'HasTarget': boolean;
    'OutputTime': string;
    'TargetName': string;
    'TimeRulePlugInName': string;
    'Links': AnalysisTemplateLinks;
}

export class AnalysisTemplateLinks {
    'Self': string;
    'Database': string;
    'Categories': string;
    'AnalysisRule': string;
    'AnalysisRulePlugIn': string;
    'TimeRule': string;
    'TimeRulePlugIn': string;
    'Target': string;
    'Security': string;
    'SecurityEntries': string;
}

export class Annotation {
    'Id': string;
    'Name': string;
    'Description': string;
    'Value': any;
    'Creator': string;
    'CreationDate': Date;
    'Modifier': string;
    'ModifyDate': Date;
    'Links': AnnotationLinks;
}

export class AnnotationLinks {
    'Self': string;
    'Owner': string;
}

export class AssetDatabase {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'ExtendedProperties': { [key: string]: Value; };
    'Links': AssetDatabaseLinks;
}

export class AssetDatabaseLinks {
    'Self': string;
    'Elements': string;
    'ElementTemplates': string;
    'EventFrames': string;
    'AssetServer': string;
    'ElementCategories': string;
    'AttributeCategories': string;
    'TableCategories': string;
    'AnalysisCategories': string;
    'AnalysisTemplates': string;
    'EnumerationSets': string;
    'Tables': string;
    'Security': string;
    'SecurityEntries': string;
}

export class AssetServer {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'IsConnected': boolean;
    'ServerVersion': string;
    'ExtendedProperties': { [key: string]: Value; };
    'Links': AssetServerLinks;
}

export class AssetServerLinks {
    'Self': string;
    'Databases': string;
    'SecurityIdentities': string;
    'SecurityMappings': string;
    'UnitClasses': string;
    'AnalysisRulePlugIns': string;
    'TimeRulePlugIns': string;
    'Security': string;
    'SecurityEntries': string;
}

export class Attribute {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'Type': string;
    'TypeQualifier': string;
    'DefaultUnitsName': string;
    'DataReferencePlugIn': string;
    'ConfigString': string;
    'IsConfigurationItem': boolean;
    'IsExcluded': boolean;
    'IsHidden': boolean;
    'IsManualDataEntry': boolean;
    'HasChildren': boolean;
    'CategoryNames': Array<string>;
    'Step': boolean;
    'TraitName': string;
    'Links': AttributeLinks;
}

export class AttributeCategory {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'Links': AttributeCategoryLinks;
}

export class AttributeCategoryLinks {
    'Self': string;
    'Database': string;
    'Security': string;
    'SecurityEntries': string;
}

export class AttributeLinks {
    'Self': string;
    'Attributes': string;
    'Element': string;
    'EventFrame': string;
    'Parent': string;
    'Template': string;
    'InterpolatedData': string;
    'RecordedData': string;
    'PlotData': string;
    'SummaryData': string;
    'Value': string;
    'EndValue': string;
    'Point': string;
    'Categories': string;
    'EnumerationSet': string;
    'Trait': string;
}

export class AttributeTemplate {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'Type': string;
    'TypeQualifier': string;
    'DefaultUnitsName': string;
    'DefaultValue': any;
    'DataReferencePlugIn': string;
    'ConfigString': string;
    'IsConfigurationItem': boolean;
    'IsExcluded': boolean;
    'IsHidden': boolean;
    'IsManualDataEntry': boolean;
    'HasChildren': boolean;
    'CategoryNames': Array<string>;
    'TraitName': string;
    'Links': AttributeTemplateLinks;
}

export class AttributeTemplateLinks {
    'Self': string;
    'AttributeTemplates': string;
    'ElementTemplate': string;
    'Parent': string;
    'Categories': string;
    'Trait': string;
}

export class AttributeTrait {
    'Name': string;
    'Abbreviation': string;
    'AllowChildAttributes': boolean;
    'AllowDuplicates': boolean;
    'IsAllowedOnRootAttribute': boolean;
    'IsTypeInherited': boolean;
    'IsUOMInherited': boolean;
    'RequireNumeric': boolean;
    'RequireString': boolean;
    'Links': AttributeTraitLinks;
}

export class AttributeTraitLinks {
    'Self': string;
}

export class CacheInstance {
    'Id': string;
    'LastRefreshTime': Date;
    'WillRefreshAfter': Date;
    'ScheduledExpirationTime': Date;
    'User': string;
}

export class DataServer {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Path': string;
    'IsConnected': boolean;
    'ServerVersion': string;
    'Links': DataServerLinks;
}

export class DataServerLinks {
    'Self': string;
    'Points': string;
    'EnumerationSets': string;
}

export class Element {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'TemplateName': string;
    'HasChildren': boolean;
    'CategoryNames': Array<string>;
    'ExtendedProperties': { [key: string]: Value; };
    'Links': ElementLinks;
}

export class ElementCategory {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'Links': ElementCategoryLinks;
}

export class ElementCategoryLinks {
    'Self': string;
    'Database': string;
    'Security': string;
    'SecurityEntries': string;
}

export class ElementLinks {
    'Self': string;
    'Analyses': string;
    'Attributes': string;
    'Elements': string;
    'Database': string;
    'Parent': string;
    'Template': string;
    'Categories': string;
    'DefaultAttribute': string;
    'EventFrames': string;
    'InterpolatedData': string;
    'RecordedData': string;
    'PlotData': string;
    'SummaryData': string;
    'Value': string;
    'EndValue': string;
    'Security': string;
    'SecurityEntries': string;
}

export class ElementTemplate {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'AllowElementToExtend': boolean;
    'BaseTemplate': string;
    'InstanceType': string;
    'NamingPattern': string;
    'CategoryNames': Array<string>;
    'ExtendedProperties': { [key: string]: Value; };
    'Severity': string;
    'CanBeAcknowledged': boolean;
    'Links': ElementTemplateLinks;
}

export class ElementTemplateLinks {
    'Self': string;
    'AnalysisTemplates': string;
    'AttributeTemplates': string;
    'Database': string;
    'Categories': string;
    'BaseTemplate': string;
    'DefaultAttribute': string;
    'Security': string;
    'SecurityEntries': string;
}

export class EnumerationSet {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'Links': EnumerationSetLinks;
    'SerializeDescription': boolean;
}

export class EnumerationSetLinks {
    'Self': string;
    'Database': string;
    'DataServer': string;
    'Values': string;
    'Security': string;
    'SecurityEntries': string;
}

export class EnumerationValue {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Value': number;
    'Path': string;
    'Links': EnumerationValueLinks;
    'SerializeWebId': boolean;
    'SerializeId': boolean;
    'SerializeDescription': boolean;
    'SerializePath': boolean;
    'SerializeLinks': boolean;
}

export class EnumerationValueLinks {
    'Self': string;
    'EnumerationSet': string;
}

export class Errors {
    'Errors': Array<string>;
}

export class EventFrame {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'TemplateName': string;
    'HasChildren': boolean;
    'CategoryNames': Array<string>;
    'ExtendedProperties': { [key: string]: Value; };
    'StartTime': Date;
    'EndTime': Date;
    'Severity': string;
    'AcknowledgedBy': string;
    'AcknowledgedDate': Date;
    'CanBeAcknowledged': boolean;
    'IsAcknowledged': boolean;
    'IsAnnotated': boolean;
    'IsLocked': boolean;
    'AreValuesCaptured': boolean;
    'RefElementWebIds': Array<string>;
    'Security': Security;
    'Links': EventFrameLinks;
}

export class EventFrameLinks {
    'Self': string;
    'Attributes': string;
    'EventFrames': string;
    'Database': string;
    'ReferencedElements': string;
    'PrimaryReferencedElement': string;
    'Parent': string;
    'Template': string;
    'DefaultAttribute': string;
    'Categories': string;
    'Annotations': string;
    'InterpolatedData': string;
    'RecordedData': string;
    'PlotData': string;
    'SummaryData': string;
    'Value': string;
    'EndValue': string;
    'Security': string;
    'SecurityEntries': string;
}

export class ItemAttribute {
    'Identifier': string;
    'IdentifierType': string;
    'Object': Attribute;
    'Exception': Errors;
}

export class ItemElement {
    'Identifier': string;
    'IdentifierType': string;
    'Object': Element;
    'Exception': Errors;
}

export class ItemEventFrame {
    'Identifier': string;
    'IdentifierType': string;
    'Object': EventFrame;
    'Exception': Errors;
}

export class ItemPoint {
    'Identifier': string;
    'IdentifierType': string;
    'Object': Point;
    'Exception': Errors;
}

export class ItemsAnalysis {
    'Items': Array<Analysis>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsAnalysisCategory {
    'Items': Array<AnalysisCategory>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsAnalysisLinks {
    'First': string;
    'Previous': string;
    'Next': string;
    'Last': string;
}

export class ItemsAnalysisRule {
    'Items': Array<AnalysisRule>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsAnalysisRulePlugIn {
    'Items': Array<AnalysisRulePlugIn>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsAnalysisTemplate {
    'Items': Array<AnalysisTemplate>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsAnnotation {
    'Items': Array<Annotation>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsAssetDatabase {
    'Items': Array<AssetDatabase>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsAssetServer {
    'Items': Array<AssetServer>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsAttribute {
    'Items': Array<Attribute>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsAttributeCategory {
    'Items': Array<AttributeCategory>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsAttributeTemplate {
    'Items': Array<AttributeTemplate>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsAttributeTrait {
    'Items': Array<AttributeTrait>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsCacheInstance {
    'Items': Array<CacheInstance>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsDataServer {
    'Items': Array<DataServer>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsElement {
    'Items': Array<Element>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsElementCategory {
    'Items': Array<ElementCategory>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsElementTemplate {
    'Items': Array<ElementTemplate>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsEnumerationSet {
    'Items': Array<EnumerationSet>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsEnumerationValue {
    'Items': Array<EnumerationValue>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsEventFrame {
    'Items': Array<EventFrame>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsItemAttribute {
    'Items': Array<ItemAttribute>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsItemElement {
    'Items': Array<ItemElement>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsItemEventFrame {
    'Items': Array<ItemEventFrame>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsItemPoint {
    'Items': Array<ItemPoint>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsItemsSubstatus {
    'Items': Array<ItemsSubstatus>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsPoint {
    'Items': Array<Point>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsPointAttribute {
    'Items': Array<PointAttribute>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsSecurityEntry {
    'Items': Array<SecurityEntry>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsSecurityIdentity {
    'Items': Array<SecurityIdentity>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsSecurityMapping {
    'Items': Array<SecurityMapping>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsSecurityRights {
    'Items': Array<SecurityRights>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsStreamSummaries {
    'Items': Array<StreamSummaries>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsStreamValue {
    'Items': Array<StreamValue>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsStreamValues {
    'Items': Array<StreamValues>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsSubstatus {
    'Items': Array<Substatus>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsSummaryValue {
    'Items': Array<SummaryValue>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsTable {
    'Items': Array<Table>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsTableCategory {
    'Items': Array<TableCategory>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsTimeRulePlugIn {
    'Items': Array<TimeRulePlugIn>;
    'Links': ItemsAnalysisLinks;
}

export class ItemsUnitClass {
    'Items': Array<UnitClass>;
    'Links': ItemsAnalysisLinks;
}

export class Landing {
    'Links': LandingLinks;
}

export class LandingLinks {
    'Self': string;
    'AssetServers': string;
    'DataServers': string;
    'Search': string;
    'System': string;
}

export class Point {
    'WebId': string;
    'Id': number;
    'Name': string;
    'Path': string;
    'Descriptor': string;
    'PointClass': string;
    'PointType': string;
    'DigitalSetName': string;
    'EngineeringUnits': string;
    'Step': boolean;
    'Future': boolean;
    'Links': PointLinks;
}

export class PointAttribute {
    'Name': string;
    'Value': any;
    'Links': PointAttributeLinks;
}

export class PointAttributeLinks {
    'Self': string;
    'Point': string;
}

export class PointLinks {
    'Self': string;
    'DataServer': string;
    'Attributes': string;
    'InterpolatedData': string;
    'RecordedData': string;
    'PlotData': string;
    'SummaryData': string;
    'Value': string;
    'EndValue': string;
}

export class Request {
    'Method': string;
    'Resource': string;
    'RequestTemplate': RequestTemplate;
    'Parameters': Array<string>;
    'Headers': { [key: string]: string; };
    'Content': string;
    'ParentIds': Array<string>;
}

export class RequestTemplate {
    'Resource': string;
}

export class Response {
    'Status': Response.StatusEnum;
    'Headers': { [key: string]: string; };
    'Content': any;
}

export namespace Response {
    export enum StatusEnum {
        NUMBER_100 = <any> 100,
        NUMBER_101 = <any> 101,
        NUMBER_200 = <any> 200,
        NUMBER_201 = <any> 201,
        NUMBER_202 = <any> 202,
        NUMBER_203 = <any> 203,
        NUMBER_204 = <any> 204,
        NUMBER_205 = <any> 205,
        NUMBER_206 = <any> 206,
        NUMBER_300 = <any> 300,
        NUMBER_301 = <any> 301,
        NUMBER_302 = <any> 302,
        NUMBER_303 = <any> 303,
        NUMBER_304 = <any> 304,
        NUMBER_305 = <any> 305,
        NUMBER_306 = <any> 306,
        NUMBER_307 = <any> 307,
        NUMBER_400 = <any> 400,
        NUMBER_401 = <any> 401,
        NUMBER_402 = <any> 402,
        NUMBER_403 = <any> 403,
        NUMBER_404 = <any> 404,
        NUMBER_405 = <any> 405,
        NUMBER_406 = <any> 406,
        NUMBER_407 = <any> 407,
        NUMBER_408 = <any> 408,
        NUMBER_409 = <any> 409,
        NUMBER_410 = <any> 410,
        NUMBER_411 = <any> 411,
        NUMBER_412 = <any> 412,
        NUMBER_413 = <any> 413,
        NUMBER_414 = <any> 414,
        NUMBER_415 = <any> 415,
        NUMBER_416 = <any> 416,
        NUMBER_417 = <any> 417,
        NUMBER_426 = <any> 426,
        NUMBER_500 = <any> 500,
        NUMBER_501 = <any> 501,
        NUMBER_502 = <any> 502,
        NUMBER_503 = <any> 503,
        NUMBER_504 = <any> 504,
        NUMBER_505 = <any> 505
    }
}
export class Security {
    'CanAnnotate': boolean;
    'CanDelete': boolean;
    'CanExecute': boolean;
    'CanRead': boolean;
    'CanReadData': boolean;
    'CanSubscribe': boolean;
    'CanSubscribeOthers': boolean;
    'CanWrite': boolean;
    'CanWriteData': boolean;
    'HasAdmin': boolean;
    'Rights': Array<string>;
}

export class SecurityEntry {
    'Name': string;
    'SecurityIdentityName': string;
    'AllowRights': Array<string>;
    'DenyRights': Array<string>;
    'Links': SecurityEntryLinks;
}

export class SecurityEntryLinks {
    'Self': string;
    'SecurableObject': string;
    'SecurityIdentity': string;
}

export class SecurityIdentity {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'IsEnabled': boolean;
    'Links': SecurityIdentityLinks;
}

export class SecurityIdentityLinks {
    'Self': string;
    'AssetServer': string;
    'SecurityMappings': string;
    'Security': string;
    'SecurityEntries': string;
}

export class SecurityMapping {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'Account': string;
    'SecurityIdentityWebId': string;
    'Links': SecurityMappingLinks;
}

export class SecurityMappingLinks {
    'Self': string;
    'AssetServer': string;
    'SecurityIdentity': string;
    'Security': string;
    'SecurityEntries': string;
}

export class SecurityRights {
    'OwnerWebId': string;
    'SecurityItem': string;
    'UserIdentity': string;
    'Links': AnnotationLinks;
}

export class StreamSummaries {
    'WebId': string;
    'Name': string;
    'Path': string;
    'Items': Array<SummaryValue>;
    'Links': StreamSummariesLinks;
}

export class StreamSummariesLinks {
    'Source': string;
}

export class StreamValue {
    'WebId': string;
    'Name': string;
    'Path': string;
    'Value': TimedValue;
    'Links': StreamSummariesLinks;
}

export class StreamValues {
    'WebId': string;
    'Name': string;
    'Path': string;
    'Items': Array<TimedValue>;
    'UnitsAbbreviation': string;
    'Links': StreamSummariesLinks;
}

export class Substatus {
    'Substatus': Substatus.SubstatusEnum;
    'Message': string;
}

export namespace Substatus {
    export enum SubstatusEnum {
        NUMBER_100 = <any> 100,
        NUMBER_101 = <any> 101,
        NUMBER_200 = <any> 200,
        NUMBER_201 = <any> 201,
        NUMBER_202 = <any> 202,
        NUMBER_203 = <any> 203,
        NUMBER_204 = <any> 204,
        NUMBER_205 = <any> 205,
        NUMBER_206 = <any> 206,
        NUMBER_300 = <any> 300,
        NUMBER_301 = <any> 301,
        NUMBER_302 = <any> 302,
        NUMBER_303 = <any> 303,
        NUMBER_304 = <any> 304,
        NUMBER_305 = <any> 305,
        NUMBER_306 = <any> 306,
        NUMBER_307 = <any> 307,
        NUMBER_400 = <any> 400,
        NUMBER_401 = <any> 401,
        NUMBER_402 = <any> 402,
        NUMBER_403 = <any> 403,
        NUMBER_404 = <any> 404,
        NUMBER_405 = <any> 405,
        NUMBER_406 = <any> 406,
        NUMBER_407 = <any> 407,
        NUMBER_408 = <any> 408,
        NUMBER_409 = <any> 409,
        NUMBER_410 = <any> 410,
        NUMBER_411 = <any> 411,
        NUMBER_412 = <any> 412,
        NUMBER_413 = <any> 413,
        NUMBER_414 = <any> 414,
        NUMBER_415 = <any> 415,
        NUMBER_416 = <any> 416,
        NUMBER_417 = <any> 417,
        NUMBER_426 = <any> 426,
        NUMBER_500 = <any> 500,
        NUMBER_501 = <any> 501,
        NUMBER_502 = <any> 502,
        NUMBER_503 = <any> 503,
        NUMBER_504 = <any> 504,
        NUMBER_505 = <any> 505
    }
}
export class SummaryValue {
    'Type': string;
    'Value': TimedValue;
}

export class SystemLanding {
    'ProductTitle': string;
    'ProductVersion': string;
    'Links': SystemLandingLinks;
}

export class SystemLandingLinks {
    'Self': string;
    'CacheInstances': string;
    'Configuration': string;
    'UserInfo': string;
    'Versions': string;
    'Status': string;
}

export class SystemStatus {
    'UpTimeInMinutes': number;
    'State': string;
    'CacheInstances': number;
}

export class Table {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'CategoryNames': Array<string>;
    'TimeZone': string;
    'ConvertToLocalTime': boolean;
    'Links': TableLinks;
}

export class TableCategory {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'Links': TableCategoryLinks;
}

export class TableCategoryLinks {
    'Self': string;
    'Database': string;
    'Security': string;
    'SecurityEntries': string;
}

export class TableData {
    'Columns': { [key: string]: string; };
    'Rows': Array<{ [key: string]: any; }>;
}

export class TableLinks {
    'Self': string;
    'Database': string;
    'Data': string;
    'Categories': string;
    'Security': string;
    'SecurityEntries': string;
}

export class TimeRule {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'ConfigString': string;
    'ConfigStringStored': string;
    'DisplayString': string;
    'EditorType': string;
    'IsConfigured': boolean;
    'IsInitializing': boolean;
    'MergeDuplicatedItems': boolean;
    'PlugInName': string;
    'Links': TimeRuleLinks;
}

export class TimeRuleLinks {
    'Self': string;
    'Analysis': string;
    'AnalysisTemplate': string;
    'PlugIn': string;
}

export class TimeRulePlugIn {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'Path': string;
    'AssemblyFileName': string;
    'AssemblyID': string;
    'AssemblyLoadProperties': Array<string>;
    'AssemblyTime': Date;
    'CompatibilityVersion': number;
    'IsBrowsable': boolean;
    'IsNonEditableConfig': boolean;
    'LoadedAssemblyTime': Date;
    'LoadedVersion': string;
    'Version': string;
    'Links': TimeRulePlugInLinks;
}

export class TimeRulePlugInLinks {
    'Self': string;
    'AssetServer': string;
}

export class TimedValue {
    'Timestamp': Date;
    'UnitsAbbreviation': string;
    'Good': boolean;
    'Questionable': boolean;
    'Substituted': boolean;
    'Value': any;
    'Exception': Errors;
}

export class TimedValues {
    'Items': Array<TimedValue>;
    'UnitsAbbreviation': string;
}

export class Unit {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Abbreviation': string;
    'Description': string;
    'Path': string;
    'Factor': number;
    'Offset': number;
    'ReferenceFactor': number;
    'ReferenceOffset': number;
    'ReferenceUnitAbbreviation': string;
    'Links': UnitLinks;
}

export class UnitClass {
    'WebId': string;
    'Id': string;
    'Name': string;
    'Description': string;
    'CanonicalUnitName': string;
    'CanonicalUnitAbbreviation': string;
    'Path': string;
    'Links': UnitClassLinks;
}

export class UnitClassLinks {
    'Self': string;
    'CanonicalUnit': string;
    'Units': string;
    'AssetServer': string;
}

export class UnitLinks {
    'Self': string;
    'Class': string;
    'ReferenceUnit': string;
}

export class UserInfo {
    'IdentityType': string;
    'Name': string;
    'IsAuthenticated': boolean;
    'SID': string;
    'ImpersonationLevel': string;
}

export class Value {
    'Value': any;
    'Exception': Errors;
}

export class Version {
    'FullVersion': string;
    'MajorMinorRevision': string;
    'Build': string;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum AnalysisApiApiKeys {
}

export class AnalysisApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: AnalysisApiApiKeys, value: string) {
        this.authentications[AnalysisApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create a security entry owned by the analysis.
     * 
     * @param webId The ID of the analysis, where the security entry will be created.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public analysisCreateSecurityEntry (webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analyses/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisCreateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling analysisCreateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an Analysis.
     * 
     * @param webId The ID of the Analysis to delete.
     */
    public analysisDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analyses/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a security entry owned by the analysis.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the analysis, where the security entry will be deleted.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public analysisDeleteSecurityEntry (name: string, webId: string, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analyses/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling analysisDeleteSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisDeleteSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an Analysis.
     * 
     * @param webId The ID of the Analysis.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Analysis;  }> {
        const localVarPath = this.basePath + '/analyses/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Analysis;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an Analysis by path.
     * This method returns an Analysis based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the Analysis.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Analysis;  }> {
        const localVarPath = this.basePath + '/analyses';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling analysisGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Analysis;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an Analysis&#39; categories.
     * 
     * @param webId The ID of the Analysis.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisGetCategories (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAnalysisCategory;  }> {
        const localVarPath = this.basePath + '/analyses/{webId}/categories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisGetCategories.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAnalysisCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the Analysis for a specified user.
     * 
     * @param webId The ID of the Analysis for the security to be checked.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisGetSecurity (webId: string, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/analyses/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling analysisGetSecurity.');
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries associated with the analysis based on the specified criteria. By default, all security entries for this analysis are returned.
     * 
     * @param webId The ID of the analysis.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisGetSecurityEntries (webId: string, nameFilter?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/analyses/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry associated with the analysis with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the analysis.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisGetSecurityEntryByName (name: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }> {
        const localVarPath = this.basePath + '/analyses/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling analysisGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisGetSecurityEntryByName.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an Analysis.
     * 
     * @param webId The ID of the Analysis to update.
     * @param analysis A partial Analysis containing the desired changes.
     */
    public analysisUpdate (webId: string, analysis: Analysis) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analyses/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisUpdate.');
        }

        // verify required parameter 'analysis' is not null or undefined
        if (analysis === null || analysis === undefined) {
            throw new Error('Required parameter analysis was null or undefined when calling analysisUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: analysis,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security entry owned by the analysis.
     * 
     * @param name The name of the security entry.
     * @param webId The ID of the analysis, where the security entry will be updated.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public analysisUpdateSecurityEntry (name: string, webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analyses/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling analysisUpdateSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisUpdateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling analysisUpdateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AnalysisCategoryApiApiKeys {
}

export class AnalysisCategoryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: AnalysisCategoryApiApiKeys, value: string) {
        this.authentications[AnalysisCategoryApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create a security entry owned by the analysis category.
     * 
     * @param webId The ID of the analysis category, where the security entry will be created.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public analysisCategoryCreateSecurityEntry (webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analysiscategories/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisCategoryCreateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling analysisCategoryCreateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an analysis category.
     * 
     * @param webId The ID of the analysis category to delete.
     */
    public analysisCategoryDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analysiscategories/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisCategoryDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a security entry owned by the analysis category.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the analysis category, where the security entry will be deleted.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public analysisCategoryDeleteSecurityEntry (name: string, webId: string, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analysiscategories/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling analysisCategoryDeleteSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisCategoryDeleteSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an analysis category.
     * 
     * @param webId The ID of the analysis category.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisCategoryGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AnalysisCategory;  }> {
        const localVarPath = this.basePath + '/analysiscategories/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisCategoryGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnalysisCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an analysis category by path.
     * 
     * @param path The path to the target analysis category.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisCategoryGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AnalysisCategory;  }> {
        const localVarPath = this.basePath + '/analysiscategories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling analysisCategoryGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnalysisCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the analysis category for a specified user.
     * 
     * @param webId The ID of the analysis category for the security to be checked.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisCategoryGetSecurity (webId: string, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/analysiscategories/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisCategoryGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling analysisCategoryGetSecurity.');
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries associated with the analysis category based on the specified criteria. By default, all security entries for this analysis category are returned.
     * 
     * @param webId The ID of the analysis category.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisCategoryGetSecurityEntries (webId: string, nameFilter?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/analysiscategories/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisCategoryGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry associated with the analysis category with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the analysis category.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisCategoryGetSecurityEntryByName (name: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }> {
        const localVarPath = this.basePath + '/analysiscategories/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling analysisCategoryGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisCategoryGetSecurityEntryByName.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an analysis category by replacing items in its definition.
     * 
     * @param webId The ID of the analysis category to update.
     * @param category A partial analysis category containing the desired changes.
     */
    public analysisCategoryUpdate (webId: string, category: AnalysisCategory) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analysiscategories/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisCategoryUpdate.');
        }

        // verify required parameter 'category' is not null or undefined
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling analysisCategoryUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: category,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security entry owned by the analysis category.
     * 
     * @param name The name of the security entry.
     * @param webId The ID of the analysis category, where the security entry will be updated.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public analysisCategoryUpdateSecurityEntry (name: string, webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analysiscategories/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling analysisCategoryUpdateSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisCategoryUpdateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling analysisCategoryUpdateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AnalysisRuleApiApiKeys {
}

export class AnalysisRuleApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: AnalysisRuleApiApiKeys, value: string) {
        this.authentications[AnalysisRuleApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create a new Analysis Rule as a child of an existing Analysis Rule.
     * 
     * @param webId The ID of the parent Analysis Rule, on which to create the child Analysis Rule.
     * @param analysisRule The definition of the new Analysis Rule.
     */
    public analysisRuleCreateAnalysisRule (webId: string, analysisRule: AnalysisRule) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analysisrules/{webId}/analysisrules'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisRuleCreateAnalysisRule.');
        }

        // verify required parameter 'analysisRule' is not null or undefined
        if (analysisRule === null || analysisRule === undefined) {
            throw new Error('Required parameter analysisRule was null or undefined when calling analysisRuleCreateAnalysisRule.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: analysisRule,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an Analysis Rule.
     * 
     * @param webId The ID of the Analysis Rule.
     */
    public analysisRuleDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analysisrules/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisRuleDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an Analysis Rule.
     * 
     * @param webId The ID of the Analysis Rule.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisRuleGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AnalysisRule;  }> {
        const localVarPath = this.basePath + '/analysisrules/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisRuleGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnalysisRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the child Analysis Rules of the Analysis Rule.
     * 
     * @param webId The ID of the parent Analysis Rule.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param nameFilter The name query string used for finding Analysis Rules. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include Analysis Rules nested further than the immediate children of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     */
    public analysisRuleGetAnalysisRules (webId: string, maxCount?: number, nameFilter?: string, searchFullHierarchy?: boolean, selectedFields?: string, sortField?: string, sortOrder?: string, startIndex?: number) : Promise<{ response: http.IncomingMessage; body: ItemsAnalysisRule;  }> {
        const localVarPath = this.basePath + '/analysisrules/{webId}/analysisrules'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisRuleGetAnalysisRules.');
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAnalysisRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an Analysis Rule by path.
     * This method returns an Analysis Rule based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the Analysis Rule.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisRuleGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AnalysisRule;  }> {
        const localVarPath = this.basePath + '/analysisrules';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling analysisRuleGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnalysisRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an Analysis Rule by replacing items in its definition.
     * 
     * @param webId The ID of the Analysis Rule.
     * @param analysisRule A partial Analysis Rule containing the desired changes.
     */
    public analysisRuleUpdate (webId: string, analysisRule: AnalysisRule) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analysisrules/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisRuleUpdate.');
        }

        // verify required parameter 'analysisRule' is not null or undefined
        if (analysisRule === null || analysisRule === undefined) {
            throw new Error('Required parameter analysisRule was null or undefined when calling analysisRuleUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: analysisRule,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AnalysisRulePlugInApiApiKeys {
}

export class AnalysisRulePlugInApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: AnalysisRulePlugInApiApiKeys, value: string) {
        this.authentications[AnalysisRulePlugInApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Retrieve an Analysis Rule Plug-in.
     * 
     * @param webId The ID of the Analysis Rule Plug-in.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisRulePlugInGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AnalysisRulePlugIn;  }> {
        const localVarPath = this.basePath + '/analysisruleplugins/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisRulePlugInGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnalysisRulePlugIn;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an Analysis Rule Plug-in by path.
     * This method returns an Analysis Rule Plug-in based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the Analysis Rule Plug-in.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisRulePlugInGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AnalysisRulePlugIn;  }> {
        const localVarPath = this.basePath + '/analysisruleplugins';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling analysisRulePlugInGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnalysisRulePlugIn;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AnalysisTemplateApiApiKeys {
}

export class AnalysisTemplateApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: AnalysisTemplateApiApiKeys, value: string) {
        this.authentications[AnalysisTemplateApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create an Analysis template based upon a specified Analysis.
     * 
     * @param analysisWebId The ID of the Analysis, on which the template is created.
     * @param name The name for the created template, which must be unique within the database&#39;s AnalysisTemplate collection. If the name ends with an asterisk (*), then a unique name will be generated based on the supplied name. The default is the specified Analysis&#39; name suffixed with an asterisk (*).
     */
    public analysisTemplateCreateFromAnalysis (analysisWebId: string, name?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analysistemplates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'analysisWebId' is not null or undefined
        if (analysisWebId === null || analysisWebId === undefined) {
            throw new Error('Required parameter analysisWebId was null or undefined when calling analysisTemplateCreateFromAnalysis.');
        }

        if (analysisWebId !== undefined) {
            queryParameters['analysisWebId'] = analysisWebId;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a security entry owned by the analysis template.
     * 
     * @param webId The ID of the analysis template, where the security entry will be created.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public analysisTemplateCreateSecurityEntry (webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analysistemplates/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisTemplateCreateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling analysisTemplateCreateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an analysis template.
     * Deleting an analysis template will delete any anlysis which was created from it, unless the analysis is tied to a notification.
     * @param webId The ID of the analysis template to update.
     */
    public analysisTemplateDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analysistemplates/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisTemplateDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a security entry owned by the analysis template.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the analysis template, where the security entry will be deleted.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public analysisTemplateDeleteSecurityEntry (name: string, webId: string, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analysistemplates/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling analysisTemplateDeleteSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisTemplateDeleteSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an analysis template.
     * 
     * @param webId The ID of the analysis template.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisTemplateGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AnalysisTemplate;  }> {
        const localVarPath = this.basePath + '/analysistemplates/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisTemplateGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnalysisTemplate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an analysis template by path.
     * This method returns an analysis template based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the analysis template.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisTemplateGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AnalysisTemplate;  }> {
        const localVarPath = this.basePath + '/analysistemplates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling analysisTemplateGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnalysisTemplate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an analysis template&#39;s categories.
     * 
     * @param webId The ID of the analysis template.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisTemplateGetCategories (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAnalysisCategory;  }> {
        const localVarPath = this.basePath + '/analysistemplates/{webId}/categories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisTemplateGetCategories.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAnalysisCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the analysis template for a specified user.
     * 
     * @param webId The ID of the analysis template for the security to be checked.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisTemplateGetSecurity (webId: string, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/analysistemplates/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisTemplateGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling analysisTemplateGetSecurity.');
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries associated with the analysis template based on the specified criteria. By default, all security entries for this analysis template are returned.
     * 
     * @param webId The ID of the analysis template.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisTemplateGetSecurityEntries (webId: string, nameFilter?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/analysistemplates/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisTemplateGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry associated with the analysis template with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the analysis template.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public analysisTemplateGetSecurityEntryByName (name: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }> {
        const localVarPath = this.basePath + '/analysistemplates/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling analysisTemplateGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisTemplateGetSecurityEntryByName.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an analysis template by replacing items in its definition.
     * 
     * @param webId The ID of the analysis template to update.
     * @param template A partial analysis template containing the desired changes.
     */
    public analysisTemplateUpdate (webId: string, template: AnalysisTemplate) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analysistemplates/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisTemplateUpdate.');
        }

        // verify required parameter 'template' is not null or undefined
        if (template === null || template === undefined) {
            throw new Error('Required parameter template was null or undefined when calling analysisTemplateUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security entry owned by the analysis template.
     * 
     * @param name The name of the security entry.
     * @param webId The ID of the analysis template, where the security entry will be updated.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public analysisTemplateUpdateSecurityEntry (name: string, webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/analysistemplates/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling analysisTemplateUpdateSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling analysisTemplateUpdateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling analysisTemplateUpdateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AssetDatabaseApiApiKeys {
}

export class AssetDatabaseApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: AssetDatabaseApiApiKeys, value: string) {
        this.authentications[AssetDatabaseApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Add a reference to an existing element to the specified database.
     * 
     * @param webId The ID of the database which the referenced element will be added to.
     * @param referencedElementWebId The ID of the referenced element. Multiple referenced elements may be specified with multiple instances of the parameter.
     * @param referenceType The name of the reference type between the parent and the referenced element. This must be a \&quot;strong\&quot; reference type. The default is \&quot;parent-child\&quot;.
     */
    public assetDatabaseAddReferencedElement (webId: string, referencedElementWebId: Array<string>, referenceType?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/referencedelements'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseAddReferencedElement.');
        }

        // verify required parameter 'referencedElementWebId' is not null or undefined
        if (referencedElementWebId === null || referencedElementWebId === undefined) {
            throw new Error('Required parameter referencedElementWebId was null or undefined when calling assetDatabaseAddReferencedElement.');
        }

        if (referencedElementWebId !== undefined) {
            queryParameters['referencedElementWebId'] = referencedElementWebId;
        }

        if (referenceType !== undefined) {
            queryParameters['referenceType'] = referenceType;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an analysis category at the Asset Database root.
     * 
     * @param webId The ID of the database in which to create the analysis category.
     * @param analysisCategory The new analysis category definition.
     */
    public assetDatabaseCreateAnalysisCategory (webId: string, analysisCategory: AnalysisCategory) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/analysiscategories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseCreateAnalysisCategory.');
        }

        // verify required parameter 'analysisCategory' is not null or undefined
        if (analysisCategory === null || analysisCategory === undefined) {
            throw new Error('Required parameter analysisCategory was null or undefined when calling assetDatabaseCreateAnalysisCategory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: analysisCategory,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an analysis template at the Asset Database root.
     * Analyses that are based on an analysis template will inherit characteristics defined in the template.
     * @param webId The ID of the database in which to create the analysis template.
     * @param template The new analysis template definition.
     */
    public assetDatabaseCreateAnalysisTemplate (webId: string, template: AnalysisTemplate) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/analysistemplates'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseCreateAnalysisTemplate.');
        }

        // verify required parameter 'template' is not null or undefined
        if (template === null || template === undefined) {
            throw new Error('Required parameter template was null or undefined when calling assetDatabaseCreateAnalysisTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an attribute category at the Asset Database root.
     * 
     * @param webId The ID of the database in which to create the attribute category.
     * @param attributeCategory The new attribute category definition.
     */
    public assetDatabaseCreateAttributeCategory (webId: string, attributeCategory: AttributeCategory) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/attributecategories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseCreateAttributeCategory.');
        }

        // verify required parameter 'attributeCategory' is not null or undefined
        if (attributeCategory === null || attributeCategory === undefined) {
            throw new Error('Required parameter attributeCategory was null or undefined when calling assetDatabaseCreateAttributeCategory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: attributeCategory,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a child element.
     * 
     * @param webId The ID of the asset database on which to create the element.
     * @param element The new element definition.
     */
    public assetDatabaseCreateElement (webId: string, element: Element) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/elements'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseCreateElement.');
        }

        // verify required parameter 'element' is not null or undefined
        if (element === null || element === undefined) {
            throw new Error('Required parameter element was null or undefined when calling assetDatabaseCreateElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: element,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an element category at the Asset Database root.
     * 
     * @param webId The ID of the database in which to create the element category.
     * @param elementCategory The new element category definition.
     */
    public assetDatabaseCreateElementCategory (webId: string, elementCategory: ElementCategory) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/elementcategories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseCreateElementCategory.');
        }

        // verify required parameter 'elementCategory' is not null or undefined
        if (elementCategory === null || elementCategory === undefined) {
            throw new Error('Required parameter elementCategory was null or undefined when calling assetDatabaseCreateElementCategory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: elementCategory,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a template at the Asset Database root. Specify InstanceType of \&quot;Element\&quot; or \&quot;EventFrame\&quot; to create element or event frame template respectively. Only these two types of templates can be created.
     * Elements and event frames that are based on an element template will inherit characteristics defined in the template.
     * @param webId The ID of the database in which to create the element template.
     * @param template The new element template definition.
     */
    public assetDatabaseCreateElementTemplate (webId: string, template: ElementTemplate) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/elementtemplates'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseCreateElementTemplate.');
        }

        // verify required parameter 'template' is not null or undefined
        if (template === null || template === undefined) {
            throw new Error('Required parameter template was null or undefined when calling assetDatabaseCreateElementTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an enumeration set at the Asset Database.
     * 
     * @param webId The ID of the database in which to create the enumeration set.
     * @param enumerationSet The new enumeration set definition.
     */
    public assetDatabaseCreateEnumerationSet (webId: string, enumerationSet: EnumerationSet) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/enumerationsets'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseCreateEnumerationSet.');
        }

        // verify required parameter 'enumerationSet' is not null or undefined
        if (enumerationSet === null || enumerationSet === undefined) {
            throw new Error('Required parameter enumerationSet was null or undefined when calling assetDatabaseCreateEnumerationSet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: enumerationSet,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an event frame.
     * 
     * @param webId The ID of the database on which to create the event frame.
     * @param eventFrame The new event frame definition.
     */
    public assetDatabaseCreateEventFrame (webId: string, eventFrame: EventFrame) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/eventframes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseCreateEventFrame.');
        }

        // verify required parameter 'eventFrame' is not null or undefined
        if (eventFrame === null || eventFrame === undefined) {
            throw new Error('Required parameter eventFrame was null or undefined when calling assetDatabaseCreateEventFrame.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: eventFrame,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a security entry owned by the asset database.
     * 
     * @param webId The ID of the asset database where the security entry will be created.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     * @param securityItem The security item of the desired security entries to be created. If the parameter is not specified, security entries of the &#39;Default&#39; security item will be created.
     */
    public assetDatabaseCreateSecurityEntry (webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean, securityItem?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseCreateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling assetDatabaseCreateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        if (securityItem !== undefined) {
            queryParameters['securityItem'] = securityItem;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a table on the Asset Database.
     * 
     * @param webId The ID of the database in which to create the table.
     * @param table The new table definition.
     */
    public assetDatabaseCreateTable (webId: string, table: Table) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/tables'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseCreateTable.');
        }

        // verify required parameter 'table' is not null or undefined
        if (table === null || table === undefined) {
            throw new Error('Required parameter table was null or undefined when calling assetDatabaseCreateTable.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: table,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a table category on the Asset Database.
     * 
     * @param webId The ID of the database in which to create the table category.
     * @param tableCategory The new table category definition.
     */
    public assetDatabaseCreateTableCategory (webId: string, tableCategory: TableCategory) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/tablecategories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseCreateTableCategory.');
        }

        // verify required parameter 'tableCategory' is not null or undefined
        if (tableCategory === null || tableCategory === undefined) {
            throw new Error('Required parameter tableCategory was null or undefined when calling assetDatabaseCreateTableCategory.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: tableCategory,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an asset database.
     * 
     * @param webId The ID of the database.
     */
    public assetDatabaseDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a security entry owned by the asset database.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the asset database where the security entry will be deleted.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     * @param securityItem The security item of the desired security entries to be deleted. If the parameter is not specified, security entries of the &#39;Default&#39; security item will be deleted.
     */
    public assetDatabaseDeleteSecurityEntry (name: string, webId: string, applyToChildren?: boolean, securityItem?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling assetDatabaseDeleteSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseDeleteSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        if (securityItem !== undefined) {
            queryParameters['securityItem'] = securityItem;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Export the asset database.
     * 
     * @param webId The ID of the database.
     * @param endTime The latest ending time for AFEventFrame, AFTransfer, and AFCase objects that may be part of the export. The default is &#39;*&#39;.
     * @param exportMode Indicates the type of export to perform. The default is &#39;StrongReferences&#39;. Multiple export modes may be specified by using multiple instances of exportMode.
     * @param startTime The earliest starting time for AFEventFrame, AFTransfer, and AFCase objects that may be part of the export. The default is &#39;*-30d&#39;.
     */
    public assetDatabaseExport (webId: string, endTime?: string, exportMode?: Array<string>, startTime?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/export'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseExport.');
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (exportMode !== undefined) {
            queryParameters['exportMode'] = exportMode;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve analyses based on the specified conditions.
     * Users can search for the analyses based on specific search parameters. If no parameters are specified in the search, the default values for each parameter will be used and will return the analyses that match the default search.
     * @param webId The ID of the database to search for the analyses.
     * @param field Specifies which of the object&#39;s properties are searched. Multiple search fields may be specified with multiple instances of the parameter. The default is &#39;Name&#39;.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param query The query string used for finding analyses. The default is null.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     */
    public assetDatabaseFindAnalyses (webId: string, field: Array<string>, maxCount?: number, query?: string, selectedFields?: string, sortField?: string, sortOrder?: string, startIndex?: number) : Promise<{ response: http.IncomingMessage; body: ItemsAnalysis;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/analyses'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseFindAnalyses.');
        }

        // verify required parameter 'field' is not null or undefined
        if (field === null || field === undefined) {
            throw new Error('Required parameter field was null or undefined when calling assetDatabaseFindAnalyses.');
        }

        if (field !== undefined) {
            queryParameters['field'] = field;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (query !== undefined) {
            queryParameters['query'] = query;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAnalysis;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a list of element attributes matching the specified filters from the specified asset database.
     * 
     * @param webId The ID of the asset database to use as the root of the search.
     * @param attributeCategory Specify that returned attributes must have this category. The default is no filter.
     * @param attributeDescriptionFilter The attribute description filter string used for finding objects. Only the first 440 characters of the description will be searched. For Asset Servers older than 2.7, a 400 status code (Bad Request) will be returned if this parameter is specified. The default is no filter.
     * @param attributeNameFilter The attribute name filter string used for finding objects. The default is no filter.
     * @param attributeType Specify that returned attributes&#39; value type must be this value type. The default is no filter.
     * @param elementCategory Specify that the owner of the returned attributes must have this category. The default is no filter.
     * @param elementDescriptionFilter The element description filter string used for finding objects. Only the first 440 characters of the description will be searched. For Asset Servers older than 2.7, a 400 status code (Bad Request) will be returned if this parameter is specified. The default is no filter.
     * @param elementNameFilter The element name filter string used for finding objects. The default is no filter.
     * @param elementTemplate Specify that the owner of the returned attributes must have this template or a template derived from this template. The default is no filter.
     * @param elementType Specify that the element of the returned attributes must have this AFElementType. The default is no filter.
     * @param maxCount The maximum number of objects to be returned (the page size). The default is 1000.
     * @param searchFullHierarchy Specifies if the search should include objects nested further than immediate children of the given resource. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     */
    public assetDatabaseFindElementAttributes (webId: string, attributeCategory?: string, attributeDescriptionFilter?: string, attributeNameFilter?: string, attributeType?: string, elementCategory?: string, elementDescriptionFilter?: string, elementNameFilter?: string, elementTemplate?: string, elementType?: string, maxCount?: number, searchFullHierarchy?: boolean, selectedFields?: string, sortField?: string, sortOrder?: string, startIndex?: number) : Promise<{ response: http.IncomingMessage; body: ItemsAttribute;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/elementattributes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseFindElementAttributes.');
        }

        if (attributeCategory !== undefined) {
            queryParameters['attributeCategory'] = attributeCategory;
        }

        if (attributeDescriptionFilter !== undefined) {
            queryParameters['attributeDescriptionFilter'] = attributeDescriptionFilter;
        }

        if (attributeNameFilter !== undefined) {
            queryParameters['attributeNameFilter'] = attributeNameFilter;
        }

        if (attributeType !== undefined) {
            queryParameters['attributeType'] = attributeType;
        }

        if (elementCategory !== undefined) {
            queryParameters['elementCategory'] = elementCategory;
        }

        if (elementDescriptionFilter !== undefined) {
            queryParameters['elementDescriptionFilter'] = elementDescriptionFilter;
        }

        if (elementNameFilter !== undefined) {
            queryParameters['elementNameFilter'] = elementNameFilter;
        }

        if (elementTemplate !== undefined) {
            queryParameters['elementTemplate'] = elementTemplate;
        }

        if (elementType !== undefined) {
            queryParameters['elementType'] = elementType;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAttribute;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a list of event frame attributes matching the specified filters from the specified asset database.
     * 
     * @param webId The ID of the asset database to use as the root of the search.
     * @param attributeCategory Specify that returned attributes must have this category. The default is no filter.
     * @param attributeDescriptionFilter The attribute description filter string used for finding objects. Only the first 440 characters of the description will be searched. For Asset Servers older than 2.7, a 400 status code (Bad Request) will be returned if this parameter is specified. The default is no filter.
     * @param attributeNameFilter The attribute name filter string used for finding objects. The default is no filter.
     * @param attributeType Specify that returned attributes&#39; value type must be this value type. The default is no filter.
     * @param endTime A string representing the latest ending time for the event frames to be matched. The endTime must be greater than or equal to the startTime. The default is &#39;*&#39;.
     * @param eventFrameCategory Specify that the owner of the returned attributes must have this category. The default is no filter.
     * @param eventFrameDescriptionFilter The event frame description filter string used for finding objects. Only the first 440 characters of the description will be searched. For Asset Servers older than 2.7, a 400 status code (Bad Request) will be returned if this parameter is specified. The default is no filter.
     * @param eventFrameNameFilter The event frame name filter string used for finding objects. The default is no filter.
     * @param eventFrameTemplate Specify that the owner of the returned attributes must have this template or a template derived from this template. The default is no filter.
     * @param maxCount The maximum number of objects to be returned (the page size). The default is 1000.
     * @param referencedElementNameFilter The name query string which must match the name of a referenced element. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include objects nested further than immediate children of the given resource. The default is &#39;false&#39;.
     * @param searchMode Determines how the startTime and endTime parameters are treated when searching for event frames.     The default is &#39;Overlapped&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     * @param startTime A string representing the earliest starting time for the event frames to be matched. startTime must be less than or equal to the endTime. The default is &#39;*-8h&#39;.
     */
    public assetDatabaseFindEventFrameAttributes (webId: string, attributeCategory?: string, attributeDescriptionFilter?: string, attributeNameFilter?: string, attributeType?: string, endTime?: string, eventFrameCategory?: string, eventFrameDescriptionFilter?: string, eventFrameNameFilter?: string, eventFrameTemplate?: string, maxCount?: number, referencedElementNameFilter?: string, searchFullHierarchy?: boolean, searchMode?: string, selectedFields?: string, sortField?: string, sortOrder?: string, startIndex?: number, startTime?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAttribute;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/eventframeattributes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseFindEventFrameAttributes.');
        }

        if (attributeCategory !== undefined) {
            queryParameters['attributeCategory'] = attributeCategory;
        }

        if (attributeDescriptionFilter !== undefined) {
            queryParameters['attributeDescriptionFilter'] = attributeDescriptionFilter;
        }

        if (attributeNameFilter !== undefined) {
            queryParameters['attributeNameFilter'] = attributeNameFilter;
        }

        if (attributeType !== undefined) {
            queryParameters['attributeType'] = attributeType;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (eventFrameCategory !== undefined) {
            queryParameters['eventFrameCategory'] = eventFrameCategory;
        }

        if (eventFrameDescriptionFilter !== undefined) {
            queryParameters['eventFrameDescriptionFilter'] = eventFrameDescriptionFilter;
        }

        if (eventFrameNameFilter !== undefined) {
            queryParameters['eventFrameNameFilter'] = eventFrameNameFilter;
        }

        if (eventFrameTemplate !== undefined) {
            queryParameters['eventFrameTemplate'] = eventFrameTemplate;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (referencedElementNameFilter !== undefined) {
            queryParameters['referencedElementNameFilter'] = referencedElementNameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (searchMode !== undefined) {
            queryParameters['searchMode'] = searchMode;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAttribute;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an Asset Database.
     * 
     * @param webId The ID of the database.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetDatabaseGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AssetDatabase;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AssetDatabase;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve analysis categories for a given Asset Database.
     * 
     * @param webId The ID of the database.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetDatabaseGetAnalysisCategories (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAnalysisCategory;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/analysiscategories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGetAnalysisCategories.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAnalysisCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve analysis templates based on the specified criteria. By default, all analysis templates in the specified Asset Database are returned.
     * Users can search for the analysis templates based on specific search parameters. If no parameters are specified in the search, the default values for each parameter will be used and will return the templates that match the default search.
     * @param webId The ID of the database to search.
     * @param field Specifies which of the object&#39;s properties are searched. Multiple search fields may be specified with multiple instances of the parameter. The default is &#39;Name&#39;.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param query The query string used for finding objects. The default is no query string.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     */
    public assetDatabaseGetAnalysisTemplates (webId: string, field: Array<string>, maxCount?: number, query?: string, selectedFields?: string, sortField?: string, sortOrder?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAnalysisTemplate;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/analysistemplates'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGetAnalysisTemplates.');
        }

        // verify required parameter 'field' is not null or undefined
        if (field === null || field === undefined) {
            throw new Error('Required parameter field was null or undefined when calling assetDatabaseGetAnalysisTemplates.');
        }

        if (field !== undefined) {
            queryParameters['field'] = field;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (query !== undefined) {
            queryParameters['query'] = query;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAnalysisTemplate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve attribute categories for a given Asset Database.
     * 
     * @param webId The ID of the database.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetDatabaseGetAttributeCategories (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAttributeCategory;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/attributecategories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGetAttributeCategories.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAttributeCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an Asset Database by path.
     * This method returns an asset database based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the database.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetDatabaseGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AssetDatabase;  }> {
        const localVarPath = this.basePath + '/assetdatabases';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling assetDatabaseGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AssetDatabase;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve element categories for a given Asset Database.
     * 
     * @param webId The ID of the database.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetDatabaseGetElementCategories (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsElementCategory;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/elementcategories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGetElementCategories.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsElementCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve element templates based on the specified criteria. Only templates of instance type \&quot;Element\&quot; and \&quot;EventFrame\&quot; are returned. By default, all element and event frame templates in the specified Asset Database are returned.
     * Users can search for the element and event frame template based on specific search parameters. If no parameters are specified in the search, the default values for each parameter will be used and will return the templates that match the default search.
     * @param webId The ID of the database to search.
     * @param field Specifies which of the object&#39;s properties are searched. Multiple search fields may be specified with multiple instances of the parameter. The default is &#39;Name&#39;.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param query The query string used for finding objects. The default is no query string.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     */
    public assetDatabaseGetElementTemplates (webId: string, field: Array<string>, maxCount?: number, query?: string, selectedFields?: string, sortField?: string, sortOrder?: string) : Promise<{ response: http.IncomingMessage; body: ItemsElementTemplate;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/elementtemplates'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGetElementTemplates.');
        }

        // verify required parameter 'field' is not null or undefined
        if (field === null || field === undefined) {
            throw new Error('Required parameter field was null or undefined when calling assetDatabaseGetElementTemplates.');
        }

        if (field !== undefined) {
            queryParameters['field'] = field;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (query !== undefined) {
            queryParameters['query'] = query;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsElementTemplate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve elements based on the specified conditions. By default, this method selects immediate children of the specified asset database.
     * Users can search for the elements based on specific search parameters. If no parameters are specified in the search, the default values for each parameter will be used and will return the elements that match the default search.
     * @param webId The ID of the database to use as the root of the search.
     * @param categoryName Specify that returned elements must have this category. The default is no category filter.
     * @param descriptionFilter Specify that returned elements must have this description. The default is no description filter.
     * @param elementType Specify that returned elements must have this type. The default type is &#39;Any&#39;.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param nameFilter The name query string used for finding objects. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include objects nested further than the immediate children of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     * @param templateName Specify that returned elements must have this template or a template derived from this template. The default is no template filter.
     */
    public assetDatabaseGetElements (webId: string, categoryName?: string, descriptionFilter?: string, elementType?: string, maxCount?: number, nameFilter?: string, searchFullHierarchy?: boolean, selectedFields?: string, sortField?: string, sortOrder?: string, startIndex?: number, templateName?: string) : Promise<{ response: http.IncomingMessage; body: ItemsElement;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/elements'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGetElements.');
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (descriptionFilter !== undefined) {
            queryParameters['descriptionFilter'] = descriptionFilter;
        }

        if (elementType !== undefined) {
            queryParameters['elementType'] = elementType;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsElement;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve enumeration sets for given asset database.
     * 
     * @param webId The ID of the database.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetDatabaseGetEnumerationSets (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsEnumerationSet;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/enumerationsets'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGetEnumerationSets.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsEnumerationSet;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve event frames based on the specified conditions. By default, returns all children of the specified root resource with a start time in the past 8 hours.
     * 
     * @param webId The ID of the asset database to use as the root of the search.
     * @param canBeAcknowledged Specify the returned event frames&#39; canBeAcknowledged property. The default is no canBeAcknowledged filter.
     * @param categoryName Specify that returned event frames must have this category. The default is no category filter.
     * @param endTime The ending time for the search. The endTime must be greater than or equal to the startTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values.
     * @param isAcknowledged Specify the returned event frames&#39; isAcknowledged property. The default no isAcknowledged filter.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param nameFilter The name query string used for finding event frames. The default is no filter.
     * @param referencedElementNameFilter The name query string which must match the name of a referenced element. The default is no filter.
     * @param referencedElementTemplateName Specify that returned event frames must have an element in the event frame&#39;s referenced elements collection that derives from the template. Specify this parameter by name.
     * @param searchFullHierarchy Specifies whether the search should include objects nested further than the immediate children of the search root. The default is &#39;false&#39;.
     * @param searchMode Determines how the startTime and endTime parameters are treated when searching for event frame objects to be included in the returned collection. If this parameter is one of the &#39;Backward*&#39; or &#39;Forward*&#39; values, none of endTime, sortField, or sortOrder may be specified. The default is &#39;Overlapped&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param severity Specify that returned event frames must have this severity. Multiple severity values may be specified with multiple instances of the parameter. The default is no severity filter.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     * @param startTime The starting time for the search. startTime must be less than or equal to the endTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*-8h&#39;.
     * @param templateName Specify that returned event frames must have this template or a template derived from this template. The default is no template filter. Specify this parameter by name.
     */
    public assetDatabaseGetEventFrames (webId: string, canBeAcknowledged?: boolean, categoryName?: string, endTime?: string, isAcknowledged?: boolean, maxCount?: number, nameFilter?: string, referencedElementNameFilter?: string, referencedElementTemplateName?: string, searchFullHierarchy?: boolean, searchMode?: string, selectedFields?: string, severity?: Array<string>, sortField?: string, sortOrder?: string, startIndex?: number, startTime?: string, templateName?: string) : Promise<{ response: http.IncomingMessage; body: ItemsEventFrame;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/eventframes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGetEventFrames.');
        }

        if (canBeAcknowledged !== undefined) {
            queryParameters['canBeAcknowledged'] = canBeAcknowledged;
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (isAcknowledged !== undefined) {
            queryParameters['isAcknowledged'] = isAcknowledged;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (referencedElementNameFilter !== undefined) {
            queryParameters['referencedElementNameFilter'] = referencedElementNameFilter;
        }

        if (referencedElementTemplateName !== undefined) {
            queryParameters['referencedElementTemplateName'] = referencedElementTemplateName;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (searchMode !== undefined) {
            queryParameters['searchMode'] = searchMode;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (severity !== undefined) {
            queryParameters['severity'] = severity;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsEventFrame;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve referenced elements based on the specified conditions. By default, this method selects all referenced elements at the root level of the asset database.
     * Users can search for the referenced elements based on specific search parameters. If no parameters are specified in the search, the default values for each parameter will be used and will return the elements that match the default search.
     * @param webId The ID of the resource to use as the root of the search.
     * @param categoryName Specify that returned elements must have this category. The default is no category filter.
     * @param descriptionFilter Specify that returned elements must have this description. The default is no description filter.
     * @param elementType Specify that returned elements must have this type. The default type is &#39;Any&#39;.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param nameFilter The name query string used for finding objects. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     * @param templateName Specify that returned elements must have this template or a template derived from this template. The default is no template filter.
     */
    public assetDatabaseGetReferencedElements (webId: string, categoryName?: string, descriptionFilter?: string, elementType?: string, maxCount?: number, nameFilter?: string, selectedFields?: string, sortField?: string, sortOrder?: string, startIndex?: number, templateName?: string) : Promise<{ response: http.IncomingMessage; body: ItemsElement;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/referencedelements'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGetReferencedElements.');
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (descriptionFilter !== undefined) {
            queryParameters['descriptionFilter'] = descriptionFilter;
        }

        if (elementType !== undefined) {
            queryParameters['elementType'] = elementType;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsElement;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the asset database for a specified user.
     * 
     * @param webId The ID of the asset database for the security to be checked.
     * @param securityItem The security item of the desired security information to be returned. Multiple security items may be specified with multiple instances of the parameter. If the parameter is not specified, only &#39;Default&#39; security item of the security information will be returned.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetDatabaseGetSecurity (webId: string, securityItem: Array<string>, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGetSecurity.');
        }

        // verify required parameter 'securityItem' is not null or undefined
        if (securityItem === null || securityItem === undefined) {
            throw new Error('Required parameter securityItem was null or undefined when calling assetDatabaseGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling assetDatabaseGetSecurity.');
        }

        if (securityItem !== undefined) {
            queryParameters['securityItem'] = securityItem;
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries of the specified security item associated with the asset database based on the specified criteria. By default, all security entries for this asset database are returned.
     * 
     * @param webId The ID of the asset database.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param securityItem The security item of the desired security entries information to be returned. If the parameter is not specified, security entries of the &#39;Default&#39; security item will be returned.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetDatabaseGetSecurityEntries (webId: string, nameFilter?: string, securityItem?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (securityItem !== undefined) {
            queryParameters['securityItem'] = securityItem;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry of the specified security item associated with the asset database with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the asset database.
     * @param securityItem The security item of the desired security entries information to be returned. If the parameter is not specified, security entries of the &#39;Default&#39; security item will be returned.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetDatabaseGetSecurityEntryByName (name: string, webId: string, securityItem?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling assetDatabaseGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGetSecurityEntryByName.');
        }

        if (securityItem !== undefined) {
            queryParameters['securityItem'] = securityItem;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve table categories for a given Asset Database.
     * 
     * @param webId The ID of the database.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetDatabaseGetTableCategories (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsTableCategory;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/tablecategories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGetTableCategories.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsTableCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve tables for given Asset Database.
     * 
     * @param webId The ID of the database.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetDatabaseGetTables (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsTable;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/tables'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseGetTables.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsTable;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Import an asset database.
     * 
     * @param webId The ID of the asset database.
     * @param importMode Indicates the type of import to perform. The default is &#39;AllowCreate | AllowUpdate | AutoCheckIn&#39;. Multiple import modes may be specified by using multiple instances of importMode.
     */
    public assetDatabaseImport (webId: string, importMode?: Array<string>) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/import'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseImport.');
        }

        if (importMode !== undefined) {
            queryParameters['importMode'] = importMode;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove a reference to an existing element from the specified database.
     * 
     * @param webId The ID of the database which the referenced element will be removed from.
     * @param referencedElementWebId The ID of the referenced element. Multiple referenced elements may be specified with multiple instances of the parameter.
     */
    public assetDatabaseRemoveReferencedElement (webId: string, referencedElementWebId: Array<string>) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/referencedelements'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseRemoveReferencedElement.');
        }

        // verify required parameter 'referencedElementWebId' is not null or undefined
        if (referencedElementWebId === null || referencedElementWebId === undefined) {
            throw new Error('Required parameter referencedElementWebId was null or undefined when calling assetDatabaseRemoveReferencedElement.');
        }

        if (referencedElementWebId !== undefined) {
            queryParameters['referencedElementWebId'] = referencedElementWebId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an asset database by replacing items in its definition.
     * 
     * @param webId The ID of the database.
     * @param database A partial database containing the desired changes.
     */
    public assetDatabaseUpdate (webId: string, database: AssetDatabase) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseUpdate.');
        }

        // verify required parameter 'database' is not null or undefined
        if (database === null || database === undefined) {
            throw new Error('Required parameter database was null or undefined when calling assetDatabaseUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: database,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security entry owned by the asset database.
     * 
     * @param name The name of the security entry.
     * @param webId The ID of the asset database where the security entry will be updated.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     * @param securityItem The security item of the desired security entries to be updated. If the parameter is not specified, security entries of the &#39;Default&#39; security item will be updated.
     */
    public assetDatabaseUpdateSecurityEntry (name: string, webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean, securityItem?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetdatabases/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling assetDatabaseUpdateSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetDatabaseUpdateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling assetDatabaseUpdateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        if (securityItem !== undefined) {
            queryParameters['securityItem'] = securityItem;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AssetServerApiApiKeys {
}

export class AssetServerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: AssetServerApiApiKeys, value: string) {
        this.authentications[AssetServerApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create an asset database.
     * 
     * @param webId The ID of the asset server on which to create the database.
     * @param database The new database definition.
     */
    public assetServerCreateAssetDatabase (webId: string, database: AssetDatabase) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/assetdatabases'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerCreateAssetDatabase.');
        }

        // verify required parameter 'database' is not null or undefined
        if (database === null || database === undefined) {
            throw new Error('Required parameter database was null or undefined when calling assetServerCreateAssetDatabase.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: database,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a security entry owned by the asset server.
     * 
     * @param webId The ID of the asset server where the security entry will be created.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     * @param securityItem The security item of the desired security entries to be created. If the parameter is not specified, security entries of the &#39;Default&#39; security item will be created.
     */
    public assetServerCreateSecurityEntry (webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean, securityItem?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerCreateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling assetServerCreateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        if (securityItem !== undefined) {
            queryParameters['securityItem'] = securityItem;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a security identity.
     * 
     * @param webId The ID of the asset server on which to create the security identity.
     * @param securityIdentity The new security identity definition.
     */
    public assetServerCreateSecurityIdentity (webId: string, securityIdentity: SecurityIdentity) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/securityidentities'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerCreateSecurityIdentity.');
        }

        // verify required parameter 'securityIdentity' is not null or undefined
        if (securityIdentity === null || securityIdentity === undefined) {
            throw new Error('Required parameter securityIdentity was null or undefined when calling assetServerCreateSecurityIdentity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityIdentity,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a security mapping.
     * 
     * @param webId The ID of the asset server on which to create the security mapping.
     * @param securityMapping The new security mapping definition.
     */
    public assetServerCreateSecurityMapping (webId: string, securityMapping: SecurityMapping) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/securitymappings'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerCreateSecurityMapping.');
        }

        // verify required parameter 'securityMapping' is not null or undefined
        if (securityMapping === null || securityMapping === undefined) {
            throw new Error('Required parameter securityMapping was null or undefined when calling assetServerCreateSecurityMapping.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityMapping,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a unit class in the specified Asset Server.
     * 
     * @param webId The ID of the server.
     * @param unitClass The new unit class definition.
     */
    public assetServerCreateUnitClass (webId: string, unitClass: UnitClass) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/unitclasses'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerCreateUnitClass.');
        }

        // verify required parameter 'unitClass' is not null or undefined
        if (unitClass === null || unitClass === undefined) {
            throw new Error('Required parameter unitClass was null or undefined when calling assetServerCreateUnitClass.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: unitClass,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a security entry owned by the asset server.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the asset server where the security entry will be deleted.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     * @param securityItem The security item of the desired security entries to be deleted. If the parameter is not specified, security entries of the &#39;Default&#39; security item will be deleted.
     */
    public assetServerDeleteSecurityEntry (name: string, webId: string, applyToChildren?: boolean, securityItem?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling assetServerDeleteSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerDeleteSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        if (securityItem !== undefined) {
            queryParameters['securityItem'] = securityItem;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an Asset Server.
     * 
     * @param webId The ID of the server.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetServerGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AssetServer;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AssetServer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a list of all Analysis Rule Plug-in&#39;s.
     * 
     * @param webId The ID of the asset server, where the Analysis Rule Plug-in&#39;s are installed.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetServerGetAnalysisRulePlugIns (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAnalysisRulePlugIn;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/analysisruleplugins'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerGetAnalysisRulePlugIns.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAnalysisRulePlugIn;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an Asset Server by name.
     * This method returns an asset server based on the name associated with it. Users should primarily search with the WebID when available.
     * @param name The name of the server.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetServerGetByName (name: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AssetServer;  }> {
        const localVarPath = this.basePath + '/assetservers#name';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling assetServerGetByName.');
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AssetServer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an Asset Server by path.
     * This method returns an asset server based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the server.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetServerGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AssetServer;  }> {
        const localVarPath = this.basePath + '/assetservers#path';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling assetServerGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AssetServer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a list of all Asset Databases on the specified Asset Server.
     * 
     * @param webId The ID of the server.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetServerGetDatabases (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAssetDatabase;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/assetdatabases'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerGetDatabases.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAssetDatabase;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the asset server for a specified user.
     * 
     * @param webId The ID of the asset server for the security to be checked.
     * @param securityItem The security item of the desired security information to be returned. Multiple security items may be specified with multiple instances of the parameter. If the parameter is not specified, only &#39;Default&#39; security item of the security information will be returned.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetServerGetSecurity (webId: string, securityItem: Array<string>, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerGetSecurity.');
        }

        // verify required parameter 'securityItem' is not null or undefined
        if (securityItem === null || securityItem === undefined) {
            throw new Error('Required parameter securityItem was null or undefined when calling assetServerGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling assetServerGetSecurity.');
        }

        if (securityItem !== undefined) {
            queryParameters['securityItem'] = securityItem;
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries of the specified security item associated with the asset server based on the specified criteria. By default, all security entries for this asset server are returned.
     * 
     * @param webId The ID of the asset server.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param securityItem The security item of the desired security entries information to be returned. If the parameter is not specified, security entries of the &#39;Default&#39; security item will be returned.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetServerGetSecurityEntries (webId: string, nameFilter?: string, securityItem?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (securityItem !== undefined) {
            queryParameters['securityItem'] = securityItem;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry of the specified security item associated with the asset server with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the asset server.
     * @param securityItem The security item of the desired security entries information to be returned. If the parameter is not specified, security entries of the &#39;Default&#39; security item will be returned.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetServerGetSecurityEntryByName (name: string, webId: string, securityItem?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling assetServerGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerGetSecurityEntryByName.');
        }

        if (securityItem !== undefined) {
            queryParameters['securityItem'] = securityItem;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve security identities based on the specified criteria. By default, all security identities in the specified Asset Server are returned.
     * 
     * @param webId The ID of the asset server to search.
     * @param field Specifies which of the object&#39;s properties are searched. The default is &#39;Name&#39;.
     * @param maxCount The maximum number of objects to be returned. The default is 1000.
     * @param query The query string used for finding objects. The default is no query string.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     */
    public assetServerGetSecurityIdentities (webId: string, field?: string, maxCount?: number, query?: string, selectedFields?: string, sortField?: string, sortOrder?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityIdentity;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/securityidentities'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerGetSecurityIdentities.');
        }

        if (field !== undefined) {
            queryParameters['field'] = field;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (query !== undefined) {
            queryParameters['query'] = query;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityIdentity;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve security identities for a specific user.
     * 
     * @param webId The ID of the server.
     * @param userIdentity The user identity to search for.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetServerGetSecurityIdentitiesForUser (webId: string, userIdentity: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityIdentity;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/securityidentities#userIdentity'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerGetSecurityIdentitiesForUser.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling assetServerGetSecurityIdentitiesForUser.');
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityIdentity;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve security mappings based on the specified criteria. By default, all security mappings in the specified Asset Server are returned.
     * 
     * @param webId The ID of the asset server to search.
     * @param field Specifies which of the object&#39;s properties are searched. The default is &#39;Name&#39;.
     * @param maxCount The maximum number of objects to be returned. The default is 1000.
     * @param query The query string used for finding objects. The default is no query string.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     */
    public assetServerGetSecurityMappings (webId: string, field?: string, maxCount?: number, query?: string, selectedFields?: string, sortField?: string, sortOrder?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityMapping;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/securitymappings'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerGetSecurityMappings.');
        }

        if (field !== undefined) {
            queryParameters['field'] = field;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (query !== undefined) {
            queryParameters['query'] = query;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityMapping;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a list of all Time Rule Plug-in&#39;s.
     * 
     * @param webId The ID of the asset server, where the Time Rule Plug-in&#39;s are installed.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetServerGetTimeRulePlugIns (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsTimeRulePlugIn;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/timeruleplugins'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerGetTimeRulePlugIns.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsTimeRulePlugIn;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a list of all unit classes on the specified Asset Server.
     * 
     * @param webId The ID of the server.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetServerGetUnitClasses (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsUnitClass;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/unitclasses'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerGetUnitClasses.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsUnitClass;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a list of all Asset Servers known to this service.
     * 
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public assetServerList (selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAssetServer;  }> {
        const localVarPath = this.basePath + '/assetservers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAssetServer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security entry owned by the asset server.
     * 
     * @param name The name of the security entry.
     * @param webId The ID of the asset server where the security entry will be updated.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     * @param securityItem The security item of the desired security entries to be updated. If the parameter is not specified, security entries of the &#39;Default&#39; security item will be updated.
     */
    public assetServerUpdateSecurityEntry (name: string, webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean, securityItem?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/assetservers/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling assetServerUpdateSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling assetServerUpdateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling assetServerUpdateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        if (securityItem !== undefined) {
            queryParameters['securityItem'] = securityItem;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AttributeApiApiKeys {
}

export class AttributeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: AttributeApiApiKeys, value: string) {
        this.authentications[AttributeApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create a new attribute as a child of the specified attribute.
     * 
     * @param webId The ID of the parent attribute on which to create the attribute.
     * @param attribute The definition of the new attribute.
     */
    public attributeCreateAttribute (webId: string, attribute: Attribute) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/attributes/{webId}/attributes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeCreateAttribute.');
        }

        // verify required parameter 'attribute' is not null or undefined
        if (attribute === null || attribute === undefined) {
            throw new Error('Required parameter attribute was null or undefined when calling attributeCreateAttribute.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: attribute,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create or update an attribute&#39;s DataReference configuration (Create/Update PI point for PI Point DataReference).
     * 
     * @param webId The ID of the attribute.
     */
    public attributeCreateConfig (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/attributes/{webId}/config'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeCreateConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an attribute.
     * 
     * @param webId The ID of the attribute.
     */
    public attributeDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/attributes/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an attribute.
     * 
     * @param webId The ID of the attribute.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Attribute;  }> {
        const localVarPath = this.basePath + '/attributes/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Attribute;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the child attributes of the specified attribute.
     * 
     * @param webId The ID of the parent attribute.
     * @param categoryName Specify that returned attributes must have this category. The default is no category filter.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param nameFilter The name query string used for finding attributes. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param showExcluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;.
     * @param showHidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     * @param templateName Specify that returned attributes must be members of this template. The default is no template filter.
     * @param valueType Specify that returned attributes&#39; value type must be the given value type. The default is no value type filter.
     */
    public attributeGetAttributes (webId: string, categoryName?: string, maxCount?: number, nameFilter?: string, searchFullHierarchy?: boolean, selectedFields?: string, showExcluded?: boolean, showHidden?: boolean, sortField?: string, sortOrder?: string, startIndex?: number, templateName?: string, valueType?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAttribute;  }> {
        const localVarPath = this.basePath + '/attributes/{webId}/attributes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeGetAttributes.');
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (showExcluded !== undefined) {
            queryParameters['showExcluded'] = showExcluded;
        }

        if (showHidden !== undefined) {
            queryParameters['showHidden'] = showHidden;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        if (valueType !== undefined) {
            queryParameters['valueType'] = valueType;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAttribute;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an attribute by path.
     * This method returns an attribute based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the attribute.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Attribute;  }> {
        const localVarPath = this.basePath + '/attributes';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling attributeGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Attribute;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an attribute&#39;s categories.
     * 
     * @param webId The ID of the attribute.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeGetCategories (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAttributeCategory;  }> {
        const localVarPath = this.basePath + '/attributes/{webId}/categories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeGetCategories.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAttributeCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve multiple attributes by web id or path.
     * 
     * @param asParallel Specifies if the retrieval processes should be run in parallel on the server. This may improve the response time for large amounts of requested attributes. The default is &#39;false&#39;.
     * @param includeMode The include mode for the return list. The default is &#39;All&#39;.
     * @param path The path of an attribute. Multiple attributes may be specified with multiple instances of the parameter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param webId The ID of an attribute. Multiple attributes may be specified with multiple instances of the parameter.
     */
    public attributeGetMultiple (asParallel?: boolean, includeMode?: string, path?: Array<string>, selectedFields?: string, webId?: Array<string>) : Promise<{ response: http.IncomingMessage; body: ItemsItemAttribute;  }> {
        const localVarPath = this.basePath + '/attributes/multiple';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (asParallel !== undefined) {
            queryParameters['asParallel'] = asParallel;
        }

        if (includeMode !== undefined) {
            queryParameters['includeMode'] = includeMode;
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsItemAttribute;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the attribute&#39;s value. This call is intended for use with attributes that have no data reference only. For attributes with a data reference, consult the documentation for Streams.
     * 
     * @param webId The ID of the attribute.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeGetValue (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: TimedValue;  }> {
        const localVarPath = this.basePath + '/attributes/{webId}/value'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeGetValue.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimedValue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set the value of a configuration item attribute. For attributes with a data reference or non-configuration item attributes, consult the documentation for streams.
     * Users must be aware of the value type that the attribute takes before changing the value. If a value entered by the user does not match the value type expressed in the attribute, it will not work or it will return an error. Users should also be careful of what the value type means, for instance, if a value type accepts strings and the user enters a number, the attribute will interpret it as a string of characters and not as the integer value that the user may have wanted.
     * @param webId The ID of the attribute.
     * @param value The value to write.
     */
    public attributeSetValue (webId: string, value: TimedValue) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/attributes/{webId}/value'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeSetValue.');
        }

        // verify required parameter 'value' is not null or undefined
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling attributeSetValue.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: value,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an attribute by replacing items in its definition.
     * If an attribute is based on a template, the user must make sure to update the attribute appropriately so that it does not conflict with the template&#39;s design. Once a template is applied to an attribute, it can not be changed.
     * @param webId The ID of the attribute.
     * @param attribute A partial attribute containing the desired changes.
     */
    public attributeUpdate (webId: string, attribute: Attribute) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/attributes/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeUpdate.');
        }

        // verify required parameter 'attribute' is not null or undefined
        if (attribute === null || attribute === undefined) {
            throw new Error('Required parameter attribute was null or undefined when calling attributeUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: attribute,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AttributeCategoryApiApiKeys {
}

export class AttributeCategoryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: AttributeCategoryApiApiKeys, value: string) {
        this.authentications[AttributeCategoryApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create a security entry owned by the attribute category.
     * 
     * @param webId The ID of the attribute category where the security entry will be created.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public attributeCategoryCreateSecurityEntry (webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/attributecategories/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeCategoryCreateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling attributeCategoryCreateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an attribute category.
     * 
     * @param webId The ID of the attribute category to delete.
     */
    public attributeCategoryDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/attributecategories/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeCategoryDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a security entry owned by the attribute category.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the attribute category where the security entry will be deleted.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public attributeCategoryDeleteSecurityEntry (name: string, webId: string, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/attributecategories/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling attributeCategoryDeleteSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeCategoryDeleteSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an attribute category.
     * 
     * @param webId The id of the attribute category.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeCategoryGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AttributeCategory;  }> {
        const localVarPath = this.basePath + '/attributecategories/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeCategoryGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AttributeCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an attribute category by path.
     * 
     * @param path The path to the target attribute category.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeCategoryGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AttributeCategory;  }> {
        const localVarPath = this.basePath + '/attributecategories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling attributeCategoryGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AttributeCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the attribute category for a specified user.
     * 
     * @param webId The ID of the attribute category for the security to be checked.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeCategoryGetSecurity (webId: string, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/attributecategories/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeCategoryGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling attributeCategoryGetSecurity.');
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries associated with the attribute category based on the specified criteria. By default, all security entries for this attribute category are returned.
     * 
     * @param webId The ID of the attribute category.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeCategoryGetSecurityEntries (webId: string, nameFilter?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/attributecategories/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeCategoryGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry associated with the attribute category with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the attribute category.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeCategoryGetSecurityEntryByName (name: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }> {
        const localVarPath = this.basePath + '/attributecategories/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling attributeCategoryGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeCategoryGetSecurityEntryByName.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an attribute category by replacing items in its definition.
     * 
     * @param webId The ID of the attribute category to update.
     * @param category A partial attribute category containing the desired changes.
     */
    public attributeCategoryUpdate (webId: string, category: AttributeCategory) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/attributecategories/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeCategoryUpdate.');
        }

        // verify required parameter 'category' is not null or undefined
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling attributeCategoryUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: category,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security entry owned by the attribute category.
     * 
     * @param name The name of the security entry.
     * @param webId The ID of the attribute category where the security entry will be updated.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public attributeCategoryUpdateSecurityEntry (name: string, webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/attributecategories/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling attributeCategoryUpdateSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeCategoryUpdateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling attributeCategoryUpdateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AttributeTemplateApiApiKeys {
}

export class AttributeTemplateApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: AttributeTemplateApiApiKeys, value: string) {
        this.authentications[AttributeTemplateApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create an attribute template as a child of another attribute template.
     * 
     * @param webId The ID of the parent attribute template on which to create the attribute template.
     * @param template The attribute template definition.
     */
    public attributeTemplateCreateAttributeTemplate (webId: string, template: AttributeTemplate) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/attributetemplates/{webId}/attributetemplates'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeTemplateCreateAttributeTemplate.');
        }

        // verify required parameter 'template' is not null or undefined
        if (template === null || template === undefined) {
            throw new Error('Required parameter template was null or undefined when calling attributeTemplateCreateAttributeTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an attribute template.
     * Deleting an attribute template will delete the attributes that were created based on the template
     * @param webId The ID of the attribute template.
     */
    public attributeTemplateDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/attributetemplates/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeTemplateDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an attribute template.
     * 
     * @param webId The ID of the attribute template.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeTemplateGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AttributeTemplate;  }> {
        const localVarPath = this.basePath + '/attributetemplates/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeTemplateGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AttributeTemplate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an attribute template&#39;s child attribute templates.
     * 
     * @param webId The ID of the attribute template.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeTemplateGetAttributeTemplates (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAttributeTemplate;  }> {
        const localVarPath = this.basePath + '/attributetemplates/{webId}/attributetemplates'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeTemplateGetAttributeTemplates.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAttributeTemplate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an attribute template by path.
     * This method returns an attribute template based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the attribute template.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeTemplateGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AttributeTemplate;  }> {
        const localVarPath = this.basePath + '/attributetemplates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling attributeTemplateGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AttributeTemplate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an attribute template&#39;s categories.
     * 
     * @param webId The ID of the attribute template.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeTemplateGetCategories (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAttributeCategory;  }> {
        const localVarPath = this.basePath + '/attributetemplates/{webId}/categories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeTemplateGetCategories.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAttributeCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an existing attribute template by replacing items in its definition.
     * Updating an attribute template will propagate changes to the attributes that were created based on the template
     * @param webId The ID of the attribute template.
     * @param template A partial attribute template containing the desired changes.
     */
    public attributeTemplateUpdate (webId: string, template: AttributeTemplate) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/attributetemplates/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling attributeTemplateUpdate.');
        }

        // verify required parameter 'template' is not null or undefined
        if (template === null || template === undefined) {
            throw new Error('Required parameter template was null or undefined when calling attributeTemplateUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AttributeTraitApiApiKeys {
}

export class AttributeTraitApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: AttributeTraitApiApiKeys, value: string) {
        this.authentications[AttributeTraitApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Retrieve an attribute trait.
     * 
     * @param name The name or abbreviation of the attribute trait.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeTraitGet (name: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: AttributeTrait;  }> {
        const localVarPath = this.basePath + '/attributetraits/{name}'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling attributeTraitGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AttributeTrait;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve all attribute traits of the specified category/categories.
     * 
     * @param category The category of the attribute traits. Multiple categories may be specified with multiple instances of the parameter. If the parameter is not specified, or if its value is \&quot;all\&quot;, then all attribute traits of all categories will be returned.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public attributeTraitGetByCategory (category: Array<string>, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAttributeTrait;  }> {
        const localVarPath = this.basePath + '/attributetraits';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'category' is not null or undefined
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling attributeTraitGetByCategory.');
        }

        if (category !== undefined) {
            queryParameters['category'] = category;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAttributeTrait;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BatchApiApiKeys {
}

export class BatchApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: BatchApiApiKeys, value: string) {
        this.authentications[BatchApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Execute a batch of requests against the service. As shown in the Sample Request, the input is a dictionary with IDs as keys and request objects as values. Each request object specifies the HTTP method and the resource and, optionally, the content and a list of parent IDs. The list of parent IDs specifies which other requests must complete before the given request will be executed. The example first creates an element, then gets the element by the response&#39;s Location header, then creates an attribute for the element. Note that the resource can be an absolute URL or a JsonPath that references the response to the parent request. The batch&#39;s response is a dictionary uses keys corresponding those provided in the request, with response objects containing a status code, response headers, and the response body. A request can alternatively specify a request template in place of a resource. In this case, a single JsonPath may select multiple tokens, and a separate subrequest will be made from the template for each token. The responses of these subrequests will returned as the content of a single outer response.
     * 
     * @param batch The batch of requests.
     */
    public batchExecute (batch: any) : Promise<{ response: http.IncomingMessage; body: { [key: string]: Response; };  }> {
        const localVarPath = this.basePath + '/batch';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'batch' is not null or undefined
        if (batch === null || batch === undefined) {
            throw new Error('Required parameter batch was null or undefined when calling batchExecute.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: batch,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: { [key: string]: Response; };  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CalculationApiApiKeys {
}

export class CalculationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: CalculationApiApiKeys, value: string) {
        this.authentications[CalculationApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Returns results of evaluating the expression over the time range from the start time to the end time at a defined interval.
     * 
     * @param endTime An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param expression A string containing the expression to be evaluated. The syntax for the expression generally follows the Performance Equation syntax as described in the PI Server documentation, with the exception that expressions which target AF objects use attribute names in place of tag names in the equation.
     * @param sampleInterval A time span specifies how often the filter expression is evaluated when computing the summary for an interval.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param startTime An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set.
     * @param webId The ID of the target object of the expression. A target object can be a Data Server, a database, an element, an event frame or an attribute. References to attributes or points are based on the target. If this parameter is not provided, the target object is set to null.
     */
    public calculationGetAtIntervals (endTime?: string, expression?: string, sampleInterval?: string, selectedFields?: string, startTime?: string, webId?: string) : Promise<{ response: http.IncomingMessage; body: TimedValues;  }> {
        const localVarPath = this.basePath + '/calculation/intervals';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (expression !== undefined) {
            queryParameters['expression'] = expression;
        }

        if (sampleInterval !== undefined) {
            queryParameters['sampleInterval'] = sampleInterval;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimedValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the result of evaluating the expression at each point in time over the time range from the start time to the end time where a recorded value exists for a member of the expression.
     * 
     * @param endTime An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param expression A string containing the expression to be evaluated. The syntax for the expression generally follows the Performance Equation syntax as described in the PI Server documentation, with the exception that expressions which target AF objects use attribute names in place of tag names in the equation.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param startTime An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set.
     * @param webId The ID of the target object of the expression. A target object can be a Data Server, a database, an element, an event frame or an attribute. References to attributes or points are based on the target. If this parameter is not provided, the target object is set to null.
     */
    public calculationGetAtRecorded (endTime?: string, expression?: string, selectedFields?: string, startTime?: string, webId?: string) : Promise<{ response: http.IncomingMessage; body: TimedValues;  }> {
        const localVarPath = this.basePath + '/calculation/recorded';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (expression !== undefined) {
            queryParameters['expression'] = expression;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimedValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the result of evaluating the expression at the specified timestamps.
     * 
     * @param expression A string containing the expression to be evaluated. The syntax for the expression generally follows the Performance Equation syntax as described in the PI Server documentation, with the exception that expressions which target AF objects use attribute names in place of tag names in the equation.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param time A list of timestamps at which to calculate the expression.
     * @param webId The ID of the target object of the expression. A target object can be a Data Server, a database, an element, an event frame or an attribute. References to attributes or points are based on the target. If this parameter is not provided, the target object is set to null.
     */
    public calculationGetAtTimes (expression?: string, selectedFields?: string, sortOrder?: string, time?: Array<string>, webId?: string) : Promise<{ response: http.IncomingMessage; body: TimedValues;  }> {
        const localVarPath = this.basePath + '/calculation/times';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (expression !== undefined) {
            queryParameters['expression'] = expression;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (time !== undefined) {
            queryParameters['time'] = time;
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimedValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the result of evaluating the expression over the time range from the start time to the end time. The time range is first divided into a number of summary intervals. Then the calculation is performed for the specified summaries over each interval.
     * 
     * @param calculationBasis Specifies the method of evaluating the data over the time range. The default is &#39;TimeWeighted&#39;.
     * @param endTime An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param expression A string containing the expression to be evaluated. The syntax for the expression generally follows the Performance Equation syntax as described in the PI Server documentation, with the exception that expressions which target AF objects use attribute names in place of tag names in the equation.
     * @param sampleInterval A time span specifies how often the filter expression is evaluated when computing the summary for an interval, if the sampleType is &#39;Interval&#39;.
     * @param sampleType A flag which specifies one or more summaries to compute for each interval over the time range. The default is &#39;ExpressionRecordedValues&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param startTime An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set.
     * @param summaryDuration The duration of each summary interval.
     * @param summaryType Specifies the kinds of summaries to produce over the range. The default is &#39;Total&#39;. Multiple summary types may be specified by using multiple instances of summaryType.
     * @param timeType Specifies how to calculate the timestamp for each interval. The default is &#39;Auto&#39;.
     * @param webId The ID of the target object of the expression. A target object can be a Data Server, a database, an element, an event frame or an attribute. References to attributes or points are based on the target. If this parameter is not provided, the target object is set to null.
     */
    public calculationGetSummary (calculationBasis?: string, endTime?: string, expression?: string, sampleInterval?: string, sampleType?: string, selectedFields?: string, startTime?: string, summaryDuration?: string, summaryType?: Array<string>, timeType?: string, webId?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSummaryValue;  }> {
        const localVarPath = this.basePath + '/calculation/summary';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (calculationBasis !== undefined) {
            queryParameters['calculationBasis'] = calculationBasis;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (expression !== undefined) {
            queryParameters['expression'] = expression;
        }

        if (sampleInterval !== undefined) {
            queryParameters['sampleInterval'] = sampleInterval;
        }

        if (sampleType !== undefined) {
            queryParameters['sampleType'] = sampleType;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (summaryDuration !== undefined) {
            queryParameters['summaryDuration'] = summaryDuration;
        }

        if (summaryType !== undefined) {
            queryParameters['summaryType'] = summaryType;
        }

        if (timeType !== undefined) {
            queryParameters['timeType'] = timeType;
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSummaryValue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ChannelApiApiKeys {
}

export class ChannelApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: ChannelApiApiKeys, value: string) {
        this.authentications[ChannelApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Retrieves a list of currently running channel instances.
     * 
     */
    public channelInstances () : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/channels/instances';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ConfigurationApiApiKeys {
}

export class ConfigurationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: ConfigurationApiApiKeys, value: string) {
        this.authentications[ConfigurationApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Delete a configuration item.
     * 
     * @param key The key of the configuration item to remove.
     */
    public configurationDelete (key: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/system/configuration/{key}'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling configurationDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the value of a configuration item.
     * 
     * @param key The key of the configuration item.
     */
    public configurationGet (key: string) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/system/configuration/{key}'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling configurationGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the current system configuration.
     * 
     */
    public configurationList () : Promise<{ response: http.IncomingMessage; body: { [key: string]: any; };  }> {
        const localVarPath = this.basePath + '/system/configuration';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: { [key: string]: any; };  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DataServerApiApiKeys {
}

export class DataServerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: DataServerApiApiKeys, value: string) {
        this.authentications[DataServerApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create an enumeration set on the Data Server.
     * 
     * @param webId The ID of the server on which to create the enumeration set.
     * @param enumerationSet The new enumeration set definition.
     */
    public dataServerCreateEnumerationSet (webId: string, enumerationSet: EnumerationSet) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/dataservers/{webId}/enumerationsets'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling dataServerCreateEnumerationSet.');
        }

        // verify required parameter 'enumerationSet' is not null or undefined
        if (enumerationSet === null || enumerationSet === undefined) {
            throw new Error('Required parameter enumerationSet was null or undefined when calling dataServerCreateEnumerationSet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: enumerationSet,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a point in the specified Data Server.
     * 
     * @param webId The ID of the server.
     * @param pointDTO The new point definition.
     */
    public dataServerCreatePoint (webId: string, pointDTO: Point) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/dataservers/{webId}/points'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling dataServerCreatePoint.');
        }

        // verify required parameter 'pointDTO' is not null or undefined
        if (pointDTO === null || pointDTO === undefined) {
            throw new Error('Required parameter pointDTO was null or undefined when calling dataServerCreatePoint.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: pointDTO,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a Data Server.
     * 
     * @param webId The ID of the server.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public dataServerGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: DataServer;  }> {
        const localVarPath = this.basePath + '/dataservers/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling dataServerGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DataServer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a Data Server by name.
     * This method returns a data server based on the name. Users should primarily search with the WebID when available.
     * @param name The name of the server.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public dataServerGetByName (name: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: DataServer;  }> {
        const localVarPath = this.basePath + '/dataservers#name';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling dataServerGetByName.');
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DataServer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a Data Server by path.
     * This method returns a data server based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the server. Note that the path supplied to this method must be of the form &#39;\\\\servername&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public dataServerGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: DataServer;  }> {
        const localVarPath = this.basePath + '/dataservers#path';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling dataServerGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DataServer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve enumeration sets for given Data Server.
     * 
     * @param webId The ID of the server.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public dataServerGetEnumerationSets (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsEnumerationSet;  }> {
        const localVarPath = this.basePath + '/dataservers/{webId}/enumerationsets'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling dataServerGetEnumerationSets.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsEnumerationSet;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a list of points on a specified Data Server.
     * Users can search for the data servers based on specific search parameters. If no parameters are specified in the search, the default values for each parameter will be used and will return the data servers that match the default search.
     * @param webId The ID of the server.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param nameFilter A query string for filtering by point name. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is &#39;0&#39;.
     */
    public dataServerGetPoints (webId: string, maxCount?: number, nameFilter?: string, selectedFields?: string, startIndex?: number) : Promise<{ response: http.IncomingMessage; body: ItemsPoint;  }> {
        const localVarPath = this.basePath + '/dataservers/{webId}/points'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling dataServerGetPoints.');
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsPoint;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a list of Data Servers known to this service.
     * This method returns a list of all available known Data Servers that the user can connect to. Even though a server may be returned in the list, the user may not have permission to access it.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public dataServerList (selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsDataServer;  }> {
        const localVarPath = this.basePath + '/dataservers';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsDataServer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ElementApiApiKeys {
}

export class ElementApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: ElementApiApiKeys, value: string) {
        this.authentications[ElementApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Add a reference to an existing element to the child elements collection.
     * 
     * @param webId The ID of the element which the referenced element will be added to.
     * @param referencedElementWebId The ID of the referenced element. Multiple referenced elements may be specified with multiple instances of the parameter.
     * @param referenceType The name of the reference type between the parent and the referenced element. The default is \&quot;parent-child\&quot;.
     */
    public elementAddReferencedElement (webId: string, referencedElementWebId: Array<string>, referenceType?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/referencedelements'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementAddReferencedElement.');
        }

        // verify required parameter 'referencedElementWebId' is not null or undefined
        if (referencedElementWebId === null || referencedElementWebId === undefined) {
            throw new Error('Required parameter referencedElementWebId was null or undefined when calling elementAddReferencedElement.');
        }

        if (referencedElementWebId !== undefined) {
            queryParameters['referencedElementWebId'] = referencedElementWebId;
        }

        if (referenceType !== undefined) {
            queryParameters['referenceType'] = referenceType;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an Analysis.
     * 
     * @param webId The ID of the element on which to create the Analysis.
     * @param analysis The new Analysis definition.
     */
    public elementCreateAnalysis (webId: string, analysis: Analysis) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/analyses'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementCreateAnalysis.');
        }

        // verify required parameter 'analysis' is not null or undefined
        if (analysis === null || analysis === undefined) {
            throw new Error('Required parameter analysis was null or undefined when calling elementCreateAnalysis.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: analysis,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new attribute of the specified element.
     * 
     * @param webId The ID of the element on which to create the attribute.
     * @param attribute The definition of the new attribute.
     */
    public elementCreateAttribute (webId: string, attribute: Attribute) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/attributes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementCreateAttribute.');
        }

        // verify required parameter 'attribute' is not null or undefined
        if (attribute === null || attribute === undefined) {
            throw new Error('Required parameter attribute was null or undefined when calling elementCreateAttribute.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: attribute,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Executes the create configuration function of the data references found within the attributes of the element, and optionally, its children.
     * 
     * @param webId The ID of the element.
     * @param includeChildElements If true, includes the child elements of the specified element.
     */
    public elementCreateConfig (webId: string, includeChildElements?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/config'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementCreateConfig.');
        }

        if (includeChildElements !== undefined) {
            queryParameters['includeChildElements'] = includeChildElements;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a child element.
     * 
     * @param webId The ID of the parent element on which to create the element.
     * @param element The new element definition.
     */
    public elementCreateElement (webId: string, element: Element) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/elements'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementCreateElement.');
        }

        // verify required parameter 'element' is not null or undefined
        if (element === null || element === undefined) {
            throw new Error('Required parameter element was null or undefined when calling elementCreateElement.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: element,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a link for a \&quot;Search Elements By Attribute Value\&quot; operation, whose queries are specified in the request content. The SearchRoot is specified by the Web Id of the root Element. If the SearchRoot is not specified, then the search starts at the Asset Database. ElementTemplate must be provided as the Web ID of the ElementTemplate, which are used to create the Elements. All the attributes in the queries must be defined as AttributeTemplates on the ElementTemplate. An array of attribute value queries are ANDed together to find the desired Element objects. At least one value query must be specified. There are limitations on SearchOperators.
     * 
     */
    public elementCreateSearchByAttribute () : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elements/searchbyattribute';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a security entry owned by the element.
     * 
     * @param webId The ID of the element where the security entry will be created.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public elementCreateSecurityEntry (webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementCreateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling elementCreateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an element.
     * 
     * @param webId The ID of the element.
     */
    public elementDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elements/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a security entry owned by the element.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the element where the security entry will be deleted.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public elementDeleteSecurityEntry (name: string, webId: string, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling elementDeleteSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementDeleteSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Execute a \&quot;Search Elements By Attribute Value\&quot; operation.
     * 
     * @param searchId The encoded search Id of the \&quot;Search Elements By Attribute Value\&quot; operation.
     * @param categoryName Specify that the owner of the returned attributes must have this category. For Asset Servers older than 2.7, a 400 status code (Bad Request) will be returned if this parameter is specified. The default is no filter.
     * @param descriptionFilter The element description filter string used for finding objects. Only the first 440 characters of the description will be searched. For Asset Servers older than 2.7, a 400 status code (Bad Request) will be returned if this parameter is specified. The default is no filter.
     * @param maxCount The maximum number of objects to be returned. The default is 1000.
     * @param nameFilter The name query string used for finding objects. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include objects nested further than the immediate children of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     */
    public elementExecuteSearchByAttribute (searchId: string, categoryName?: string, descriptionFilter?: string, maxCount?: number, nameFilter?: string, searchFullHierarchy?: boolean, selectedFields?: string, sortField?: string, sortOrder?: string, startIndex?: number) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elements/searchbyattribute/{searchId}'
            .replace('{' + 'searchId' + '}', String(searchId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'searchId' is not null or undefined
        if (searchId === null || searchId === undefined) {
            throw new Error('Required parameter searchId was null or undefined when calling elementExecuteSearchByAttribute.');
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (descriptionFilter !== undefined) {
            queryParameters['descriptionFilter'] = descriptionFilter;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a list of element attributes matching the specified filters from the specified element.
     * 
     * @param webId The ID of the element to use as the root of the search.
     * @param attributeCategory Specify that returned attributes must have this category. The default is no filter.
     * @param attributeDescriptionFilter The attribute description filter string used for finding objects. Only the first 440 characters of the description will be searched. For Asset Servers older than 2.7, a 400 status code (Bad Request) will be returned if this parameter is specified. The default is no filter.
     * @param attributeNameFilter The attribute name filter string used for finding objects. The default is no filter.
     * @param attributeType Specify that returned attributes&#39; value type must be this value type. The default is no filter.
     * @param elementCategory Specify that the owner of the returned attributes must have this category. The default is no filter.
     * @param elementDescriptionFilter The element description filter string used for finding objects. Only the first 440 characters of the description will be searched. For Asset Servers older than 2.7, a 400 status code (Bad Request) will be returned if this parameter is specified. The default is no filter.
     * @param elementNameFilter The element name filter string used for finding objects. The default is no filter.
     * @param elementTemplate Specify that the owner of the returned attributes must have this template or a template derived from this template. The default is no filter.
     * @param elementType Specify that the element of the returned attributes must have this AFElementType. The default is no filter.
     * @param maxCount The maximum number of objects to be returned (the page size). The default is 1000.
     * @param searchFullHierarchy Specifies if the search should include objects nested further than immediate children of the given resource. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     */
    public elementFindElementAttributes (webId: string, attributeCategory?: string, attributeDescriptionFilter?: string, attributeNameFilter?: string, attributeType?: string, elementCategory?: string, elementDescriptionFilter?: string, elementNameFilter?: string, elementTemplate?: string, elementType?: string, maxCount?: number, searchFullHierarchy?: boolean, selectedFields?: string, sortField?: string, sortOrder?: string, startIndex?: number) : Promise<{ response: http.IncomingMessage; body: ItemsAttribute;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/elementattributes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementFindElementAttributes.');
        }

        if (attributeCategory !== undefined) {
            queryParameters['attributeCategory'] = attributeCategory;
        }

        if (attributeDescriptionFilter !== undefined) {
            queryParameters['attributeDescriptionFilter'] = attributeDescriptionFilter;
        }

        if (attributeNameFilter !== undefined) {
            queryParameters['attributeNameFilter'] = attributeNameFilter;
        }

        if (attributeType !== undefined) {
            queryParameters['attributeType'] = attributeType;
        }

        if (elementCategory !== undefined) {
            queryParameters['elementCategory'] = elementCategory;
        }

        if (elementDescriptionFilter !== undefined) {
            queryParameters['elementDescriptionFilter'] = elementDescriptionFilter;
        }

        if (elementNameFilter !== undefined) {
            queryParameters['elementNameFilter'] = elementNameFilter;
        }

        if (elementTemplate !== undefined) {
            queryParameters['elementTemplate'] = elementTemplate;
        }

        if (elementType !== undefined) {
            queryParameters['elementType'] = elementType;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAttribute;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an element.
     * 
     * @param webId The ID of the element.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Element;  }> {
        const localVarPath = this.basePath + '/elements/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Element;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve analyses based on the specified conditions.
     * Users can search for the analyses based on specific search parameters. If no parameters are specified in the search, the default values for each parameter will be used and will return the analyses that match the default search.
     * @param webId The ID of the element, which is the Target of the analyses.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     */
    public elementGetAnalyses (webId: string, maxCount?: number, selectedFields?: string, sortField?: string, sortOrder?: string, startIndex?: number) : Promise<{ response: http.IncomingMessage; body: ItemsAnalysis;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/analyses'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementGetAnalyses.');
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAnalysis;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the attributes of the specified element.
     * 
     * @param webId The ID of the element.
     * @param categoryName Specify that returned attributes must have this category. The default is no category filter.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param nameFilter The name query string used for finding attributes. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param showExcluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;.
     * @param showHidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     * @param templateName Specify that returned attributes must be members of this template. The default is no template filter.
     * @param valueType Specify that returned attributes&#39; value type must be the given value type. The default is no value type filter.
     */
    public elementGetAttributes (webId: string, categoryName?: string, maxCount?: number, nameFilter?: string, searchFullHierarchy?: boolean, selectedFields?: string, showExcluded?: boolean, showHidden?: boolean, sortField?: string, sortOrder?: string, startIndex?: number, templateName?: string, valueType?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAttribute;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/attributes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementGetAttributes.');
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (showExcluded !== undefined) {
            queryParameters['showExcluded'] = showExcluded;
        }

        if (showHidden !== undefined) {
            queryParameters['showHidden'] = showHidden;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        if (valueType !== undefined) {
            queryParameters['valueType'] = valueType;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAttribute;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an element by path.
     * This method returns an element based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the element.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Element;  }> {
        const localVarPath = this.basePath + '/elements';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling elementGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Element;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an element&#39;s categories.
     * 
     * @param webId The ID of the element.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementGetCategories (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsElementCategory;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/categories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementGetCategories.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsElementCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve elements based on the specified conditions. By default, this method selects immediate children of the specified element.
     * Users can search for the elements based on specific search parameters. If no parameters are specified in the search, the default values for each parameter will be used and will return the elements that match the default search.
     * @param webId The ID of the element to use as the root of the search.
     * @param categoryName Specify that returned elements must have this category. The default is no category filter.
     * @param descriptionFilter Specify that returned elements must have this description. The default is no description filter.
     * @param elementType Specify that returned elements must have this type. The default type is &#39;Any&#39;.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param nameFilter The name query string used for finding objects. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include objects nested further than the immediate children of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     * @param templateName Specify that returned elements must have this template or a template derived from this template. The default is no template filter.
     */
    public elementGetElements (webId: string, categoryName?: string, descriptionFilter?: string, elementType?: string, maxCount?: number, nameFilter?: string, searchFullHierarchy?: boolean, selectedFields?: string, sortField?: string, sortOrder?: string, startIndex?: number, templateName?: string) : Promise<{ response: http.IncomingMessage; body: ItemsElement;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/elements'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementGetElements.');
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (descriptionFilter !== undefined) {
            queryParameters['descriptionFilter'] = descriptionFilter;
        }

        if (elementType !== undefined) {
            queryParameters['elementType'] = elementType;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsElement;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve event frames that reference this element based on the specified conditions. By default, returns all event frames that reference this element with a start time in the past 8 hours.
     * 
     * @param webId The ID of the element whose related event frames are sought.
     * @param canBeAcknowledged Specify the returned event frames&#39; canBeAcknowledged property. The default is no canBeAcknowledged filter.
     * @param categoryName Specify that returned event frames must have this category. The default is no category filter.
     * @param endTime The ending time for the search. The endTime must be greater than or equal to the startTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values.
     * @param isAcknowledged Specify the returned event frames&#39; isAcknowledged property. The default no isAcknowledged filter.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param nameFilter The name query string used for finding event frames. The default is no filter.
     * @param searchMode Determines how the startTime and endTime parameters are treated when searching for event frame objects to be included in the returned collection. If this parameter is one of the &#39;Backward*&#39; or &#39;Forward*&#39; values, none of endTime, sortField, or sortOrder may be specified. The default is &#39;Overlapped&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param severity Specify that returned event frames must have this severity. Multiple severity values may be specified with multiple instances of the parameter. The default is no severity filter.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     * @param startTime The starting time for the search. startTime must be less than or equal to the endTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*-8h&#39;.
     * @param templateName Specify that returned event frames must have this template or a template derived from this template. The default is no template filter. Specify this parameter by name.
     */
    public elementGetEventFrames (webId: string, canBeAcknowledged?: boolean, categoryName?: string, endTime?: string, isAcknowledged?: boolean, maxCount?: number, nameFilter?: string, searchMode?: string, selectedFields?: string, severity?: Array<string>, sortField?: string, sortOrder?: string, startIndex?: number, startTime?: string, templateName?: string) : Promise<{ response: http.IncomingMessage; body: ItemsEventFrame;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/eventframes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementGetEventFrames.');
        }

        if (canBeAcknowledged !== undefined) {
            queryParameters['canBeAcknowledged'] = canBeAcknowledged;
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (isAcknowledged !== undefined) {
            queryParameters['isAcknowledged'] = isAcknowledged;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchMode !== undefined) {
            queryParameters['searchMode'] = searchMode;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (severity !== undefined) {
            queryParameters['severity'] = severity;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsEventFrame;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve multiple elements by web id or path.
     * 
     * @param asParallel Specifies if the retrieval processes should be run in parallel on the server. This may improve the response time for large amounts of requested attributes. The default is &#39;false&#39;.
     * @param includeMode The include mode for the return list. The default is &#39;All&#39;.
     * @param path The path of an element. Multiple elements may be specified with multiple instances of the parameter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param webId The ID of an element. Multiple elements may be specified with multiple instances of the parameter.
     */
    public elementGetMultiple (asParallel?: boolean, includeMode?: string, path?: Array<string>, selectedFields?: string, webId?: Array<string>) : Promise<{ response: http.IncomingMessage; body: ItemsItemElement;  }> {
        const localVarPath = this.basePath + '/elements/multiple';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (asParallel !== undefined) {
            queryParameters['asParallel'] = asParallel;
        }

        if (includeMode !== undefined) {
            queryParameters['includeMode'] = includeMode;
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsItemElement;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve referenced elements based on the specified conditions. By default, this method selects all referenced elements of the current resource.
     * Users can search for the referenced elements based on specific search parameters. If no parameters are specified in the search, the default values for each parameter will be used and will return the elements that match the default search.
     * @param webId The ID of the resource to use as the root of the search.
     * @param categoryName Specify that returned elements must have this category. The default is no category filter.
     * @param descriptionFilter Specify that returned elements must have this description. The default is no description filter.
     * @param elementType Specify that returned elements must have this type. The default type is &#39;Any&#39;.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param nameFilter The name query string used for finding objects. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     * @param templateName Specify that returned elements must have this template or a template derived from this template. The default is no template filter.
     */
    public elementGetReferencedElements (webId: string, categoryName?: string, descriptionFilter?: string, elementType?: string, maxCount?: number, nameFilter?: string, selectedFields?: string, sortField?: string, sortOrder?: string, startIndex?: number, templateName?: string) : Promise<{ response: http.IncomingMessage; body: ItemsElement;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/referencedelements'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementGetReferencedElements.');
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (descriptionFilter !== undefined) {
            queryParameters['descriptionFilter'] = descriptionFilter;
        }

        if (elementType !== undefined) {
            queryParameters['elementType'] = elementType;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsElement;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the element for a specified user.
     * 
     * @param webId The ID of the element for the security to be checked.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementGetSecurity (webId: string, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling elementGetSecurity.');
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries associated with the element based on the specified criteria. By default, all security entries for this element are returned.
     * 
     * @param webId The ID of the element.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementGetSecurityEntries (webId: string, nameFilter?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry associated with the element with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the element.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementGetSecurityEntryByName (name: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling elementGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementGetSecurityEntryByName.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove a reference to an existing element from the child elements collection.
     * 
     * @param webId The ID of the element which the referenced element will be removed from.
     * @param referencedElementWebId The ID of the referenced element. Multiple referenced elements may be specified with multiple instances of the parameter.
     */
    public elementRemoveReferencedElement (webId: string, referencedElementWebId: Array<string>) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/referencedelements'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementRemoveReferencedElement.');
        }

        // verify required parameter 'referencedElementWebId' is not null or undefined
        if (referencedElementWebId === null || referencedElementWebId === undefined) {
            throw new Error('Required parameter referencedElementWebId was null or undefined when calling elementRemoveReferencedElement.');
        }

        if (referencedElementWebId !== undefined) {
            queryParameters['referencedElementWebId'] = referencedElementWebId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an element by replacing items in its definition.
     * 
     * @param webId The ID of the element.
     * @param element A partial element containing the desired changes.
     */
    public elementUpdate (webId: string, element: Element) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elements/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementUpdate.');
        }

        // verify required parameter 'element' is not null or undefined
        if (element === null || element === undefined) {
            throw new Error('Required parameter element was null or undefined when calling elementUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: element,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security entry owned by the element.
     * 
     * @param name The name of the security entry.
     * @param webId The ID of the element where the security entry will be updated.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public elementUpdateSecurityEntry (name: string, webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elements/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling elementUpdateSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementUpdateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling elementUpdateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ElementCategoryApiApiKeys {
}

export class ElementCategoryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: ElementCategoryApiApiKeys, value: string) {
        this.authentications[ElementCategoryApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create a security entry owned by the element category.
     * 
     * @param webId The ID of the element category where the security entry will be created.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public elementCategoryCreateSecurityEntry (webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elementcategories/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementCategoryCreateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling elementCategoryCreateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an element category.
     * 
     * @param webId The ID of the element category to delete.
     */
    public elementCategoryDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elementcategories/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementCategoryDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a security entry owned by the element category.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the element category where the security entry will be deleted.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public elementCategoryDeleteSecurityEntry (name: string, webId: string, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elementcategories/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling elementCategoryDeleteSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementCategoryDeleteSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an element category.
     * 
     * @param webId The id of the element category.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementCategoryGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ElementCategory;  }> {
        const localVarPath = this.basePath + '/elementcategories/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementCategoryGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ElementCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an element category by path.
     * 
     * @param path The path to the target element category.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementCategoryGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ElementCategory;  }> {
        const localVarPath = this.basePath + '/elementcategories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling elementCategoryGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ElementCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the element category for a specified user.
     * 
     * @param webId The ID of the element category for the security to be checked.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementCategoryGetSecurity (webId: string, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/elementcategories/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementCategoryGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling elementCategoryGetSecurity.');
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries associated with the element category based on the specified criteria. By default, all security entries for this element category are returned.
     * 
     * @param webId The ID of the element category.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementCategoryGetSecurityEntries (webId: string, nameFilter?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/elementcategories/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementCategoryGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry associated with the element category with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the element category.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementCategoryGetSecurityEntryByName (name: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }> {
        const localVarPath = this.basePath + '/elementcategories/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling elementCategoryGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementCategoryGetSecurityEntryByName.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an element category by replacing items in its definition.
     * 
     * @param webId The ID of the element category to update.
     * @param elementCategory A partial element category containing the desired changes.
     */
    public elementCategoryUpdate (webId: string, elementCategory: ElementCategory) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elementcategories/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementCategoryUpdate.');
        }

        // verify required parameter 'elementCategory' is not null or undefined
        if (elementCategory === null || elementCategory === undefined) {
            throw new Error('Required parameter elementCategory was null or undefined when calling elementCategoryUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: elementCategory,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security entry owned by the element category.
     * 
     * @param name The name of the security entry.
     * @param webId The ID of the element category where the security entry will be updated.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public elementCategoryUpdateSecurityEntry (name: string, webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elementcategories/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling elementCategoryUpdateSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementCategoryUpdateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling elementCategoryUpdateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ElementTemplateApiApiKeys {
}

export class ElementTemplateApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: ElementTemplateApiApiKeys, value: string) {
        this.authentications[ElementTemplateApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create an attribute template.
     * 
     * @param webId The ID of the element template on which to create the attribute template.
     * @param template The attribute template definition.
     */
    public elementTemplateCreateAttributeTemplate (webId: string, template: AttributeTemplate) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elementtemplates/{webId}/attributetemplates'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementTemplateCreateAttributeTemplate.');
        }

        // verify required parameter 'template' is not null or undefined
        if (template === null || template === undefined) {
            throw new Error('Required parameter template was null or undefined when calling elementTemplateCreateAttributeTemplate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a security entry owned by the element template.
     * 
     * @param webId The ID of the element template where the security entry will be created.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public elementTemplateCreateSecurityEntry (webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elementtemplates/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementTemplateCreateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling elementTemplateCreateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an element template.
     * Deleting an element template will delete all associated templated data from elements which were created from it.
     * @param webId The ID of the element template to update.
     */
    public elementTemplateDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elementtemplates/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementTemplateDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a security entry owned by the element template.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the element template where the security entry will be deleted.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public elementTemplateDeleteSecurityEntry (name: string, webId: string, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elementtemplates/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling elementTemplateDeleteSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementTemplateDeleteSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an element template.
     * 
     * @param webId The ID of the element template.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementTemplateGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ElementTemplate;  }> {
        const localVarPath = this.basePath + '/elementtemplates/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementTemplateGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ElementTemplate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get analysis templates for an element template.
     * 
     * @param webId The ID of the element template.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementTemplateGetAnalysisTemplates (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAnalysisTemplate;  }> {
        const localVarPath = this.basePath + '/elementtemplates/{webId}/analysistemplates'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementTemplateGetAnalysisTemplates.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAnalysisTemplate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get child attribute templates for an element template.
     * 
     * @param webId The ID of the element template.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param showInherited Specifies if the result should include attribute templates inherited from base element templates. The default is &#39;false&#39;.
     */
    public elementTemplateGetAttributeTemplates (webId: string, selectedFields?: string, showInherited?: boolean) : Promise<{ response: http.IncomingMessage; body: ItemsAttributeTemplate;  }> {
        const localVarPath = this.basePath + '/elementtemplates/{webId}/attributetemplates'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementTemplateGetAttributeTemplates.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (showInherited !== undefined) {
            queryParameters['showInherited'] = showInherited;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAttributeTemplate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an element template by path.
     * This method returns an element template based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the element template.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementTemplateGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ElementTemplate;  }> {
        const localVarPath = this.basePath + '/elementtemplates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling elementTemplateGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ElementTemplate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an element template&#39;s categories.
     * 
     * @param webId The ID of the element template.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param showInherited Specifies if the result should include categories inherited from base element templates. The default is &#39;false&#39;.
     */
    public elementTemplateGetCategories (webId: string, selectedFields?: string, showInherited?: boolean) : Promise<{ response: http.IncomingMessage; body: ItemsElementCategory;  }> {
        const localVarPath = this.basePath + '/elementtemplates/{webId}/categories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementTemplateGetCategories.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (showInherited !== undefined) {
            queryParameters['showInherited'] = showInherited;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsElementCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the element template for a specified user.
     * 
     * @param webId The ID of the element template for the security to be checked.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementTemplateGetSecurity (webId: string, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/elementtemplates/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementTemplateGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling elementTemplateGetSecurity.');
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries associated with the element template based on the specified criteria. By default, all security entries for this element template are returned.
     * 
     * @param webId The ID of the element template.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementTemplateGetSecurityEntries (webId: string, nameFilter?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/elementtemplates/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementTemplateGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry associated with the element template with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the element template.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public elementTemplateGetSecurityEntryByName (name: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/elementtemplates/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling elementTemplateGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementTemplateGetSecurityEntryByName.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an element template by replacing items in its definition.
     * Updating the InstanceType property of an element template will not affect any elements that have already been created from this template; it will only affect any future elements created from this template. All other changes will be propagated to elements based on this template.
     * @param webId The ID of the element template to update.
     * @param template A partial element template containing the desired changes.
     */
    public elementTemplateUpdate (webId: string, template: ElementTemplate) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elementtemplates/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementTemplateUpdate.');
        }

        // verify required parameter 'template' is not null or undefined
        if (template === null || template === undefined) {
            throw new Error('Required parameter template was null or undefined when calling elementTemplateUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: template,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security entry owned by the element template.
     * 
     * @param name The name of the security entry.
     * @param webId The ID of the element template where the security entry will be updated.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public elementTemplateUpdateSecurityEntry (name: string, webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/elementtemplates/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling elementTemplateUpdateSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling elementTemplateUpdateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling elementTemplateUpdateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EnumerationSetApiApiKeys {
}

export class EnumerationSetApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: EnumerationSetApiApiKeys, value: string) {
        this.authentications[EnumerationSetApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create a security entry owned by the enumeration set.
     * 
     * @param webId The ID of the enumeration set where the security entry will be created.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public enumerationSetCreateSecurityEntry (webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/enumerationsets/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling enumerationSetCreateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling enumerationSetCreateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an enumeration value for a enumeration set.
     * 
     * @param webId The ID of the enumeration set on which to create the enumeration value.
     * @param enumerationValue The new enumeration value definition.
     */
    public enumerationSetCreateValue (webId: string, enumerationValue: EnumerationValue) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/enumerationsets/{webId}/enumerationvalues'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling enumerationSetCreateValue.');
        }

        // verify required parameter 'enumerationValue' is not null or undefined
        if (enumerationValue === null || enumerationValue === undefined) {
            throw new Error('Required parameter enumerationValue was null or undefined when calling enumerationSetCreateValue.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: enumerationValue,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an enumeration set.
     * 
     * @param webId The ID of the enumeration set to delete.
     */
    public enumerationSetDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/enumerationsets/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling enumerationSetDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a security entry owned by the enumeration set.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the enumeration set where the security entry will be deleted.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public enumerationSetDeleteSecurityEntry (name: string, webId: string, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/enumerationsets/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling enumerationSetDeleteSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling enumerationSetDeleteSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an enumeration set.
     * 
     * @param webId The ID of the enumeration set.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public enumerationSetGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: EnumerationSet;  }> {
        const localVarPath = this.basePath + '/enumerationsets/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling enumerationSetGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EnumerationSet;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an enumeration set by path.
     * This method returns an enumeration set based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the target enumeration set.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public enumerationSetGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: EnumerationSet;  }> {
        const localVarPath = this.basePath + '/enumerationsets';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling enumerationSetGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EnumerationSet;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the enumeration set for a specified user.
     * 
     * @param webId The ID of the enumeration set for the security to be checked.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public enumerationSetGetSecurity (webId: string, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/enumerationsets/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling enumerationSetGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling enumerationSetGetSecurity.');
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries associated with the enumeration set based on the specified criteria. By default, all security entries for this enumeration set are returned.
     * 
     * @param webId The ID of the enumeration set.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public enumerationSetGetSecurityEntries (webId: string, nameFilter?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/enumerationsets/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling enumerationSetGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry associated with the enumeration set with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the enumeration set.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public enumerationSetGetSecurityEntryByName (name: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }> {
        const localVarPath = this.basePath + '/enumerationsets/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling enumerationSetGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling enumerationSetGetSecurityEntryByName.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an enumeration set&#39;s values.
     * 
     * @param webId The ID of the enumeration set.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public enumerationSetGetValues (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsEnumerationValue;  }> {
        const localVarPath = this.basePath + '/enumerationsets/{webId}/enumerationvalues'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling enumerationSetGetValues.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsEnumerationValue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an enumeration set by replacing items in its definition.
     * 
     * @param webId The ID of the enumeration set to update.
     * @param enumerationSet A partial enumeration set containing the desired changes.
     */
    public enumerationSetUpdate (webId: string, enumerationSet: EnumerationSet) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/enumerationsets/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling enumerationSetUpdate.');
        }

        // verify required parameter 'enumerationSet' is not null or undefined
        if (enumerationSet === null || enumerationSet === undefined) {
            throw new Error('Required parameter enumerationSet was null or undefined when calling enumerationSetUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: enumerationSet,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security entry owned by the enumeration set.
     * 
     * @param name The name of the security entry.
     * @param webId The ID of the enumeration set where the security entry will be updated.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public enumerationSetUpdateSecurityEntry (name: string, webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/enumerationsets/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling enumerationSetUpdateSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling enumerationSetUpdateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling enumerationSetUpdateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EnumerationValueApiApiKeys {
}

export class EnumerationValueApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: EnumerationValueApiApiKeys, value: string) {
        this.authentications[EnumerationValueApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Delete an enumeration value from an enumeration set.
     * Deleting a value will remove it from the enumeration set along with any value references within the PI Web API system.
     * @param webId The ID of the enumeration value.
     */
    public enumerationValueDeleteEnumerationValue (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/enumerationvalues/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling enumerationValueDeleteEnumerationValue.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an enumeration value mapping
     * 
     * @param webId The ID of the enumeration value.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public enumerationValueGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: EnumerationValue;  }> {
        const localVarPath = this.basePath + '/enumerationvalues/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling enumerationValueGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EnumerationValue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an enumeration value by path.
     * This method returns a enumeration value based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the target enumeration value.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public enumerationValueGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: EnumerationValue;  }> {
        const localVarPath = this.basePath + '/enumerationvalues';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling enumerationValueGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EnumerationValue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an enumeration value by replacing items in its definition.
     * 
     * @param webId The ID of the enumeration value to update.
     * @param enumerationValue A partial enumeration value containing the desired changes.
     */
    public enumerationValueUpdateEnumerationValue (webId: string, enumerationValue: EnumerationValue) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/enumerationvalues/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling enumerationValueUpdateEnumerationValue.');
        }

        // verify required parameter 'enumerationValue' is not null or undefined
        if (enumerationValue === null || enumerationValue === undefined) {
            throw new Error('Required parameter enumerationValue was null or undefined when calling enumerationValueUpdateEnumerationValue.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: enumerationValue,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EventFrameApiApiKeys {
}

export class EventFrameApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: EventFrameApiApiKeys, value: string) {
        this.authentications[EventFrameApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Calls the EventFrame&#39;s Acknowledge method.
     * 
     * @param webId The ID of the event frame.
     */
    public eventFrameAcknowledge (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/acknowledge'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameAcknowledge.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calls the EventFrame&#39;s CaptureValues method.
     * 
     * @param webId The ID of the event frame.
     */
    public eventFrameCaptureValues (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/attributes/capture'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameCaptureValues.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an annotation on an event frame.
     * 
     * @param webId The ID of the owner event frame on which to create the annotation.
     * @param annotation The new annotation definition.
     */
    public eventFrameCreateAnnotation (webId: string, annotation: Annotation) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/annotations'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameCreateAnnotation.');
        }

        // verify required parameter 'annotation' is not null or undefined
        if (annotation === null || annotation === undefined) {
            throw new Error('Required parameter annotation was null or undefined when calling eventFrameCreateAnnotation.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: annotation,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new attribute of the specified event frame.
     * 
     * @param webId The ID of the event frame on which to create the attribute.
     * @param attribute The definition of the new attribute.
     */
    public eventFrameCreateAttribute (webId: string, attribute: Attribute) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/attributes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameCreateAttribute.');
        }

        // verify required parameter 'attribute' is not null or undefined
        if (attribute === null || attribute === undefined) {
            throw new Error('Required parameter attribute was null or undefined when calling eventFrameCreateAttribute.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: attribute,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Executes the create configuration function of the data references found within the attributes of the event frame, and optionally, its children.
     * 
     * @param webId The ID of the event frame.
     * @param includeChildElements If true, includes the child event frames of the specified event frame.
     */
    public eventFrameCreateConfig (webId: string, includeChildElements?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/config'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameCreateConfig.');
        }

        if (includeChildElements !== undefined) {
            queryParameters['includeChildElements'] = includeChildElements;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an event frame as a child of the specified event frame.
     * 
     * @param webId The ID of the parent event frame on which to create the event frame.
     * @param eventFrame The new event frame definition.
     */
    public eventFrameCreateEventFrame (webId: string, eventFrame: EventFrame) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/eventframes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameCreateEventFrame.');
        }

        // verify required parameter 'eventFrame' is not null or undefined
        if (eventFrame === null || eventFrame === undefined) {
            throw new Error('Required parameter eventFrame was null or undefined when calling eventFrameCreateEventFrame.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: eventFrame,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a link for a \&quot;Search EventFrames By Attribute Value\&quot; operation, whose queries are specified in the request content. The SearchRoot is specified by the Web Id of the root EventFrame. If the SearchRoot is not specified, then the search starts at the Asset Database. ElementTemplate must be provided as the Web ID of the ElementTemplate, which are used to create the EventFrames. All the attributes in the queries must be defined as AttributeTemplates on the ElementTemplate. An array of attribute value queries are ANDed together to find the desired Element objects. At least one value query must be specified. There are limitations on SearchOperators.
     * 
     */
    public eventFrameCreateSearchByAttribute () : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/searchbyattribute';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a security entry owned by the event frame.
     * 
     * @param webId The ID of the event frame where the security entry will be created.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public eventFrameCreateSecurityEntry (webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameCreateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling eventFrameCreateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an event frame.
     * 
     * @param webId The ID of the event frame to delete.
     */
    public eventFrameDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete an annotation on an event frame.
     * 
     * @param id The Annotation identifier of the annotation to be deleted.
     * @param webId The ID of the owner event frame of the annotation to delete.
     */
    public eventFrameDeleteAnnotation (id: string, webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/annotations/{id}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling eventFrameDeleteAnnotation.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameDeleteAnnotation.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a security entry owned by the event frame.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the event frame where the security entry will be deleted.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public eventFrameDeleteSecurityEntry (name: string, webId: string, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling eventFrameDeleteSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameDeleteSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Execute a \&quot;Search EventFrames By Attribute Value\&quot; operation.
     * 
     * @param searchId The encoded search Id of the \&quot;Search EventFrames By Attribute Value\&quot; operation.
     * @param canBeAcknowledged Specify the returned event frames&#39; canBeAcknowledged property. The default is no canBeAcknowledged filter.
     * @param endTime The ending time for the search. endTime must be greater than or equal to the startTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*&#39;.
     * @param isAcknowledged Specify the returned event frames&#39; isAcknowledged property. The default no isAcknowledged filter.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param nameFilter The name query string used for finding event frames. The default is no filter.
     * @param referencedElementNameFilter The name query string which must match the name of a referenced element. The default is no filter.
     * @param searchFullHierarchy Specifies whether the search should include objects nested further than the immediate children of the search root. The default is &#39;false&#39;.
     * @param searchMode Determines how the startTime and endTime parameters are treated when searching for event frame objects to be included in the returned collection. The default is &#39;Overlapped&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param severity Specify that returned event frames must have this severity. Multiple severity values may be specified with multiple instances of the parameter. The default is no severity filter.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     * @param startTime The starting time for the search. startTime must be less than or equal to the endTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*-8h&#39;.
     */
    public eventFrameExecuteSearchByAttribute (searchId: string, canBeAcknowledged?: boolean, endTime?: string, isAcknowledged?: boolean, maxCount?: number, nameFilter?: string, referencedElementNameFilter?: string, searchFullHierarchy?: boolean, searchMode?: string, selectedFields?: string, severity?: Array<string>, sortField?: string, sortOrder?: string, startIndex?: number, startTime?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/searchbyattribute/{searchId}'
            .replace('{' + 'searchId' + '}', String(searchId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'searchId' is not null or undefined
        if (searchId === null || searchId === undefined) {
            throw new Error('Required parameter searchId was null or undefined when calling eventFrameExecuteSearchByAttribute.');
        }

        if (canBeAcknowledged !== undefined) {
            queryParameters['canBeAcknowledged'] = canBeAcknowledged;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (isAcknowledged !== undefined) {
            queryParameters['isAcknowledged'] = isAcknowledged;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (referencedElementNameFilter !== undefined) {
            queryParameters['referencedElementNameFilter'] = referencedElementNameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (searchMode !== undefined) {
            queryParameters['searchMode'] = searchMode;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (severity !== undefined) {
            queryParameters['severity'] = severity;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves a list of event frame attributes matching the specified filters from the specified event frame.
     * 
     * @param webId The ID of the event frame to use as the root of the search.
     * @param attributeCategory Specify that returned attributes must have this category. The default is no filter.
     * @param attributeDescriptionFilter The attribute description filter string used for finding objects. Only the first 440 characters of the description will be searched. For Asset Servers older than 2.7, a 400 status code (Bad Request) will be returned if this parameter is specified. The default is no filter.
     * @param attributeNameFilter The attribute name filter string used for finding objects. The default is no filter.
     * @param attributeType Specify that returned attributes&#39; value type must be this value type. The default is no filter.
     * @param endTime A string representing the latest ending time for the event frames to be matched. The endTime must be greater than or equal to the startTime. The default is &#39;*&#39;.
     * @param eventFrameCategory Specify that the owner of the returned attributes must have this category. The default is no filter.
     * @param eventFrameDescriptionFilter The event frame description filter string used for finding objects. Only the first 440 characters of the description will be searched. For Asset Servers older than 2.7, a 400 status code (Bad Request) will be returned if this parameter is specified. The default is no filter.
     * @param eventFrameNameFilter The event frame name filter string used for finding objects. The default is no filter.
     * @param eventFrameTemplate Specify that the owner of the returned attributes must have this template or a template derived from this template. The default is no filter.
     * @param maxCount The maximum number of objects to be returned (the page size). The default is 1000.
     * @param referencedElementNameFilter The name query string which must match the name of a referenced element. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include objects nested further than immediate children of the given resource. The default is &#39;false&#39;.
     * @param searchMode Determines how the startTime and endTime parameters are treated when searching for event frames.     The default is &#39;Overlapped&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     * @param startTime A string representing the earliest starting time for the event frames to be matched. startTime must be less than or equal to the endTime. The default is &#39;*-8h&#39;.
     */
    public eventFrameFindEventFrameAttributes (webId: string, attributeCategory?: string, attributeDescriptionFilter?: string, attributeNameFilter?: string, attributeType?: string, endTime?: string, eventFrameCategory?: string, eventFrameDescriptionFilter?: string, eventFrameNameFilter?: string, eventFrameTemplate?: string, maxCount?: number, referencedElementNameFilter?: string, searchFullHierarchy?: boolean, searchMode?: string, selectedFields?: string, sortField?: string, sortOrder?: string, startIndex?: number, startTime?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAttribute;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/eventframeattributes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameFindEventFrameAttributes.');
        }

        if (attributeCategory !== undefined) {
            queryParameters['attributeCategory'] = attributeCategory;
        }

        if (attributeDescriptionFilter !== undefined) {
            queryParameters['attributeDescriptionFilter'] = attributeDescriptionFilter;
        }

        if (attributeNameFilter !== undefined) {
            queryParameters['attributeNameFilter'] = attributeNameFilter;
        }

        if (attributeType !== undefined) {
            queryParameters['attributeType'] = attributeType;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (eventFrameCategory !== undefined) {
            queryParameters['eventFrameCategory'] = eventFrameCategory;
        }

        if (eventFrameDescriptionFilter !== undefined) {
            queryParameters['eventFrameDescriptionFilter'] = eventFrameDescriptionFilter;
        }

        if (eventFrameNameFilter !== undefined) {
            queryParameters['eventFrameNameFilter'] = eventFrameNameFilter;
        }

        if (eventFrameTemplate !== undefined) {
            queryParameters['eventFrameTemplate'] = eventFrameTemplate;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (referencedElementNameFilter !== undefined) {
            queryParameters['referencedElementNameFilter'] = referencedElementNameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (searchMode !== undefined) {
            queryParameters['searchMode'] = searchMode;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAttribute;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an event frame.
     * 
     * @param webId The ID of the event frame.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public eventFrameGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: EventFrame;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventFrame;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a specific annotation on an event frame.
     * 
     * @param id The Annotation identifier of the specific annotation.
     * @param webId The ID of the owner event frame.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public eventFrameGetAnnotationById (id: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Annotation;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/annotations/{id}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling eventFrameGetAnnotationById.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameGetAnnotationById.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Annotation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an event frame&#39;s annotations.
     * 
     * @param webId The ID of the owner event frame.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public eventFrameGetAnnotations (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAnnotation;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/annotations'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameGetAnnotations.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAnnotation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the attributes of the specified event frame.
     * 
     * @param webId The ID of the event frame.
     * @param categoryName Specify that returned attributes must have this category. The default is no category filter.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param nameFilter The name query string used for finding attributes. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param showExcluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;.
     * @param showHidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     * @param templateName Specify that returned attributes must be members of this template. The default is no template filter.
     * @param valueType Specify that returned attributes&#39; value type must be the given value type. The default is no value type filter.
     */
    public eventFrameGetAttributes (webId: string, categoryName?: string, maxCount?: number, nameFilter?: string, searchFullHierarchy?: boolean, selectedFields?: string, showExcluded?: boolean, showHidden?: boolean, sortField?: string, sortOrder?: string, startIndex?: number, templateName?: string, valueType?: string) : Promise<{ response: http.IncomingMessage; body: ItemsAttribute;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/attributes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameGetAttributes.');
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (showExcluded !== undefined) {
            queryParameters['showExcluded'] = showExcluded;
        }

        if (showHidden !== undefined) {
            queryParameters['showHidden'] = showHidden;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        if (valueType !== undefined) {
            queryParameters['valueType'] = valueType;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsAttribute;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve an event frame by path.
     * This method returns an event frame based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the event frame.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public eventFrameGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: EventFrame;  }> {
        const localVarPath = this.basePath + '/eventframes';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling eventFrameGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventFrame;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an event frame&#39;s categories.
     * 
     * @param webId The ID of the event frame.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public eventFrameGetCategories (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsElementCategory;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/categories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameGetCategories.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsElementCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve event frames based on the specified conditions. By default, returns all children of the specified root event frame with a start time in the past 8 hours.
     * 
     * @param webId The ID of the event frame to use as the root of the search.
     * @param canBeAcknowledged Specify the returned event frames&#39; canBeAcknowledged property. The default is no canBeAcknowledged filter.
     * @param categoryName Specify that returned event frames must have this category. The default is no category filter.
     * @param endTime The ending time for the search. The endTime must be greater than or equal to the startTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values.
     * @param isAcknowledged Specify the returned event frames&#39; isAcknowledged property. The default no isAcknowledged filter.
     * @param maxCount The maximum number of objects to be returned per call (page size). The default is 1000.
     * @param nameFilter The name query string used for finding event frames. The default is no filter.
     * @param referencedElementNameFilter The name query string which must match the name of a referenced element. The default is no filter.
     * @param referencedElementTemplateName Specify that returned event frames must have an element in the event frame&#39;s referenced elements collection that derives from the template. Specify this parameter by name.
     * @param searchFullHierarchy Specifies whether the search should include objects nested further than the immediate children of the search root. The default is &#39;false&#39;.
     * @param searchMode Determines how the startTime and endTime parameters are treated when searching for event frame objects to be included in the returned collection. If this parameter is one of the &#39;Backward*&#39; or &#39;Forward*&#39; values, none of endTime, sortField, or sortOrder may be specified. The default is &#39;Overlapped&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param severity Specify that returned event frames must have this severity. Multiple severity values may be specified with multiple instances of the parameter. The default is no severity filter.
     * @param sortField The field or property of the object used to sort the returned collection. The default is &#39;Name&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values.
     * @param startIndex The starting index (zero based) of the items to be returned. The default is 0.
     * @param startTime The starting time for the search. startTime must be less than or equal to the endTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*-8h&#39;.
     * @param templateName Specify that returned event frames must have this template or a template derived from this template. The default is no template filter. Specify this parameter by name.
     */
    public eventFrameGetEventFrames (webId: string, canBeAcknowledged?: boolean, categoryName?: string, endTime?: string, isAcknowledged?: boolean, maxCount?: number, nameFilter?: string, referencedElementNameFilter?: string, referencedElementTemplateName?: string, searchFullHierarchy?: boolean, searchMode?: string, selectedFields?: string, severity?: Array<string>, sortField?: string, sortOrder?: string, startIndex?: number, startTime?: string, templateName?: string) : Promise<{ response: http.IncomingMessage; body: ItemsEventFrame;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/eventframes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameGetEventFrames.');
        }

        if (canBeAcknowledged !== undefined) {
            queryParameters['canBeAcknowledged'] = canBeAcknowledged;
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (isAcknowledged !== undefined) {
            queryParameters['isAcknowledged'] = isAcknowledged;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (referencedElementNameFilter !== undefined) {
            queryParameters['referencedElementNameFilter'] = referencedElementNameFilter;
        }

        if (referencedElementTemplateName !== undefined) {
            queryParameters['referencedElementTemplateName'] = referencedElementTemplateName;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (searchMode !== undefined) {
            queryParameters['searchMode'] = searchMode;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (severity !== undefined) {
            queryParameters['severity'] = severity;
        }

        if (sortField !== undefined) {
            queryParameters['sortField'] = sortField;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (startIndex !== undefined) {
            queryParameters['startIndex'] = startIndex;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsEventFrame;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve multiple event frames by web ids or paths.
     * 
     * @param asParallel Specifies if the retrieval processes should be run in parallel on the server. This may improve the response time for large amounts of requested attributes. The default is &#39;false&#39;.
     * @param includeMode The include mode for the return list. The default is &#39;All&#39;.
     * @param path The path of an event frame. Multiple event frames may be specified with multiple instances of the parameter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param webId The ID of an event frame. Multiple event frames may be specified with multiple instances of the parameter.
     */
    public eventFrameGetMultiple (asParallel?: boolean, includeMode?: string, path?: Array<string>, selectedFields?: string, webId?: Array<string>) : Promise<{ response: http.IncomingMessage; body: ItemsItemEventFrame;  }> {
        const localVarPath = this.basePath + '/eventframes/multiple';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (asParallel !== undefined) {
            queryParameters['asParallel'] = asParallel;
        }

        if (includeMode !== undefined) {
            queryParameters['includeMode'] = includeMode;
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsItemEventFrame;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the event frame&#39;s referenced elements.
     * 
     * @param webId The ID of the event frame whose referenced elements should be retrieved.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public eventFrameGetReferencedElements (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsElement;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/referencedelements'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameGetReferencedElements.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsElement;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the event frame for a specified user.
     * 
     * @param webId The ID of the event frame for the security to be checked.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public eventFrameGetSecurity (webId: string, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling eventFrameGetSecurity.');
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries associated with the event frame based on the specified criteria. By default, all security entries for this event frame are returned.
     * 
     * @param webId The ID of the event frame.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public eventFrameGetSecurityEntries (webId: string, nameFilter?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry associated with the event frame with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the event frame.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public eventFrameGetSecurityEntryByName (name: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling eventFrameGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameGetSecurityEntryByName.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an event frame by replacing items in its definition.
     * 
     * @param webId The ID of the event frame to update.
     * @param eventFrame A partial event frame containing the desired changes.
     */
    public eventFrameUpdate (webId: string, eventFrame: EventFrame) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameUpdate.');
        }

        // verify required parameter 'eventFrame' is not null or undefined
        if (eventFrame === null || eventFrame === undefined) {
            throw new Error('Required parameter eventFrame was null or undefined when calling eventFrameUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: eventFrame,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update an annotation on an event frame by replacing items in its definition.
     * 
     * @param id The Annotation identifier of the annotation to be updated.
     * @param webId The ID of the owner event frame of the annotation to update.
     * @param annotation A partial annotation containing the desired changes.
     */
    public eventFrameUpdateAnnotation (id: string, webId: string, annotation: Annotation) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/annotations/{id}'
            .replace('{' + 'id' + '}', String(id))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling eventFrameUpdateAnnotation.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameUpdateAnnotation.');
        }

        // verify required parameter 'annotation' is not null or undefined
        if (annotation === null || annotation === undefined) {
            throw new Error('Required parameter annotation was null or undefined when calling eventFrameUpdateAnnotation.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: annotation,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security entry owned by the event frame.
     * 
     * @param name The name of the security entry.
     * @param webId The ID of the event frame where the security entry will be updated.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public eventFrameUpdateSecurityEntry (name: string, webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/eventframes/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling eventFrameUpdateSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling eventFrameUpdateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling eventFrameUpdateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HomeApiApiKeys {
}

export class HomeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: HomeApiApiKeys, value: string) {
        this.authentications[HomeApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get top level links for this PI System Web API instance.
     * 
     */
    public homeGet () : Promise<{ response: http.IncomingMessage; body: Landing;  }> {
        const localVarPath = this.basePath + '/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Landing;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PointApiApiKeys {
}

export class PointApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: PointApiApiKeys, value: string) {
        this.authentications[PointApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Delete a point.
     * 
     * @param webId The ID of the point.
     */
    public pointDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/points/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling pointDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a point.
     * 
     * @param webId The ID of the point.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public pointGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Point;  }> {
        const localVarPath = this.basePath + '/points/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling pointGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Point;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a point attribute by name.
     * 
     * @param name The name of the attribute.
     * @param webId The ID of the point.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public pointGetAttributeByName (name: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: PointAttribute;  }> {
        const localVarPath = this.basePath + '/points/{webId}/attributes/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling pointGetAttributeByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling pointGetAttributeByName.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PointAttribute;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get point attributes.
     * 
     * @param webId The ID of the point.
     * @param name The name of a point attribute to be returned. Multiple attributes may be specified with multiple instances of the parameter.
     * @param nameFilter The filter to the names of the list of point attributes to be returned. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public pointGetAttributes (webId: string, name?: Array<string>, nameFilter?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsPointAttribute;  }> {
        const localVarPath = this.basePath + '/points/{webId}/attributes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling pointGetAttributes.');
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsPointAttribute;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a point by path.
     * This method returns a PI Point based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the point.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public pointGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Point;  }> {
        const localVarPath = this.basePath + '/points';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling pointGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Point;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve multiple points by web id or path.
     * 
     * @param asParallel Specifies if the retrieval processes should be run in parallel on the server. This may improve the response time for large amounts of requested points. The default is &#39;false&#39;.
     * @param includeMode The include mode for the return list. The default is &#39;All&#39;.
     * @param path The path of a point. Multiple points may be specified with multiple instances of the parameter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param webId The ID of a point. Multiple points may be specified with multiple instances of the parameter.
     */
    public pointGetMultiple (asParallel?: boolean, includeMode?: string, path?: Array<string>, selectedFields?: string, webId?: Array<string>) : Promise<{ response: http.IncomingMessage; body: ItemsItemPoint;  }> {
        const localVarPath = this.basePath + '/points/multiple';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (asParallel !== undefined) {
            queryParameters['asParallel'] = asParallel;
        }

        if (includeMode !== undefined) {
            queryParameters['includeMode'] = includeMode;
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsItemPoint;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a point.
     * 
     * @param webId The ID of the point.
     * @param pointDTO A partial point containing the desired changes.
     */
    public pointUpdate (webId: string, pointDTO: Point) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/points/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling pointUpdate.');
        }

        // verify required parameter 'pointDTO' is not null or undefined
        if (pointDTO === null || pointDTO === undefined) {
            throw new Error('Required parameter pointDTO was null or undefined when calling pointUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: pointDTO,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SecurityIdentityApiApiKeys {
}

export class SecurityIdentityApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: SecurityIdentityApiApiKeys, value: string) {
        this.authentications[SecurityIdentityApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Delete a security identity.
     * 
     * @param webId The ID of the security identity.
     */
    public securityIdentityDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/securityidentities/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling securityIdentityDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a security identity.
     * 
     * @param webId The ID of the security identity.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public securityIdentityGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityIdentity;  }> {
        const localVarPath = this.basePath + '/securityidentities/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling securityIdentityGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityIdentity;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a security identity by path.
     * This method returns a security identity based on the path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the security identity.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public securityIdentityGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityIdentity;  }> {
        const localVarPath = this.basePath + '/securityidentities';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling securityIdentityGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityIdentity;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the security identity for a specified user.
     * 
     * @param webId The ID of the security identity for the security to be checked.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public securityIdentityGetSecurity (webId: string, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/securityidentities/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling securityIdentityGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling securityIdentityGetSecurity.');
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries associated with the security identity based on the specified criteria. By default, all security entries for this security identity are returned.
     * 
     * @param webId The ID of the security identity.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public securityIdentityGetSecurityEntries (webId: string, nameFilter?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/securityidentities/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling securityIdentityGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry associated with the security identity with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the security identity.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public securityIdentityGetSecurityEntryByName (name: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }> {
        const localVarPath = this.basePath + '/securityidentities/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling securityIdentityGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling securityIdentityGetSecurityEntryByName.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get security mappings for the specified security identity.
     * 
     * @param webId The ID of the security identity.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public securityIdentityGetSecurityMappings (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityMapping;  }> {
        const localVarPath = this.basePath + '/securityidentities/{webId}/securitymappings'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling securityIdentityGetSecurityMappings.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityMapping;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security identity by replacing items in its definition.
     * 
     * @param webId The ID of the security identity.
     * @param securityIdentity A partial security identity containing the desired changes.
     */
    public securityIdentityUpdate (webId: string, securityIdentity: SecurityIdentity) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/securityidentities/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling securityIdentityUpdate.');
        }

        // verify required parameter 'securityIdentity' is not null or undefined
        if (securityIdentity === null || securityIdentity === undefined) {
            throw new Error('Required parameter securityIdentity was null or undefined when calling securityIdentityUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityIdentity,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SecurityMappingApiApiKeys {
}

export class SecurityMappingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: SecurityMappingApiApiKeys, value: string) {
        this.authentications[SecurityMappingApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Delete a security mapping.
     * 
     * @param webId The ID of the security mapping.
     */
    public securityMappingDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/securitymappings/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling securityMappingDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a security mapping.
     * 
     * @param webId The ID of the security mapping.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public securityMappingGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityMapping;  }> {
        const localVarPath = this.basePath + '/securitymappings/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling securityMappingGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityMapping;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a security mapping by path.
     * This method returns a security mapping based on the path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the security mapping.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public securityMappingGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityMapping;  }> {
        const localVarPath = this.basePath + '/securitymappings';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling securityMappingGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityMapping;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the security mapping for a specified user.
     * 
     * @param webId The ID of the security mapping for the security to be checked.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public securityMappingGetSecurity (webId: string, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/securitymappings/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling securityMappingGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling securityMappingGetSecurity.');
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries associated with the security mapping based on the specified criteria. By default, all security entries for this security mapping are returned.
     * 
     * @param webId The ID of the security mapping.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public securityMappingGetSecurityEntries (webId: string, nameFilter?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/securitymappings/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling securityMappingGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry associated with the security mapping with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the security mapping.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public securityMappingGetSecurityEntryByName (name: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }> {
        const localVarPath = this.basePath + '/securitymappings/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling securityMappingGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling securityMappingGetSecurityEntryByName.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security mapping by replacing items in its definition.
     * 
     * @param webId The ID of the security mapping.
     * @param securityMapping A partial security mapping containing the desired changes.
     */
    public securityMappingUpdate (webId: string, securityMapping: SecurityMapping) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/securitymappings/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling securityMappingUpdate.');
        }

        // verify required parameter 'securityMapping' is not null or undefined
        if (securityMapping === null || securityMapping === undefined) {
            throw new Error('Required parameter securityMapping was null or undefined when calling securityMappingUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityMapping,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StreamApiApiKeys {
}

export class StreamApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: StreamApiApiKeys, value: string) {
        this.authentications[StreamApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Opens a channel that will send messages about any value changes for the specified stream.
     * 
     * @param webId The ID of the stream.
     * @param includeInitialValues Specified if the channel should send a message with the current value of the stream after the connection is opened. The default is &#39;false&#39;.
     */
    public streamGetChannel (webId: string, includeInitialValues?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/streams/{webId}/channel'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamGetChannel.');
        }

        if (includeInitialValues !== undefined) {
            queryParameters['includeInitialValues'] = includeInitialValues;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the end-of-stream value of the stream.
     * 
     * @param webId The ID of the stream.
     * @param desiredUnits The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public streamGetEnd (webId: string, desiredUnits?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: TimedValue;  }> {
        const localVarPath = this.basePath + '/streams/{webId}/end'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamGetEnd.');
        }

        if (desiredUnits !== undefined) {
            queryParameters['desiredUnits'] = desiredUnits;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimedValue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves interpolated values over the specified time range at the specified sampling interval.
     * 
     * @param webId The ID of the stream.
     * @param desiredUnits The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure.
     * @param endTime An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param filterExpression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering.
     * @param includeFilteredValues Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted.
     * @param interval The sampling interval, in AFTimeSpan format.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param startTime An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamGetInterpolated (webId: string, desiredUnits?: string, endTime?: string, filterExpression?: string, includeFilteredValues?: boolean, interval?: string, selectedFields?: string, startTime?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: TimedValues;  }> {
        const localVarPath = this.basePath + '/streams/{webId}/interpolated'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamGetInterpolated.');
        }

        if (desiredUnits !== undefined) {
            queryParameters['desiredUnits'] = desiredUnits;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (filterExpression !== undefined) {
            queryParameters['filterExpression'] = filterExpression;
        }

        if (includeFilteredValues !== undefined) {
            queryParameters['includeFilteredValues'] = includeFilteredValues;
        }

        if (interval !== undefined) {
            queryParameters['interval'] = interval;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimedValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves interpolated values over the specified time range at the specified sampling interval.
     * 
     * @param webId The ID of the stream.
     * @param desiredUnits The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure.
     * @param filterExpression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering.
     * @param includeFilteredValues Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param time The timestamp at which to retrieve an interpolated value. Multiple timestamps may be specified with multiple instances of the parameter.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamGetInterpolatedAtTimes (webId: string, desiredUnits?: string, filterExpression?: string, includeFilteredValues?: boolean, selectedFields?: string, sortOrder?: string, time?: Array<string>, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: TimedValues;  }> {
        const localVarPath = this.basePath + '/streams/{webId}/interpolatedattimes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamGetInterpolatedAtTimes.');
        }

        if (desiredUnits !== undefined) {
            queryParameters['desiredUnits'] = desiredUnits;
        }

        if (filterExpression !== undefined) {
            queryParameters['filterExpression'] = filterExpression;
        }

        if (includeFilteredValues !== undefined) {
            queryParameters['includeFilteredValues'] = includeFilteredValues;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (time !== undefined) {
            queryParameters['time'] = time;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimedValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves values over the specified time range suitable for plotting over the number of intervals (typically represents pixels).
     * For each interval, the data available is examined and significant values are returned. Each interval can produce up to 5 values if they are unique, the first value in the interval, the last value, the highest value, the lowest value and at most one exceptional point (bad status or digital state).
     * @param webId The ID of the stream.
     * @param desiredUnits The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure.
     * @param endTime An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param intervals The number of intervals to plot over. Typically, this would be the number of horizontal pixels in the trend. The default is &#39;24&#39;. For each interval, the data available is examined and significant values are returned. Each interval can produce up to 5 values if they are unique, the first value in the interval, the last value, the highest value, the lowest value and at most one exceptional point (bad status or digital state).
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param startTime An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamGetPlot (webId: string, desiredUnits?: string, endTime?: string, intervals?: number, selectedFields?: string, startTime?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: TimedValues;  }> {
        const localVarPath = this.basePath + '/streams/{webId}/plot'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamGetPlot.');
        }

        if (desiredUnits !== undefined) {
            queryParameters['desiredUnits'] = desiredUnits;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (intervals !== undefined) {
            queryParameters['intervals'] = intervals;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimedValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of compressed values for the requested time range from the source provider.
     * Returned times are affected by the specified boundary type. If no values are found for the time range and conditions specified then the HTTP response will be success, with a body containing an empty array of Items. When specifying true for the includeFilteredValues parameter, consecutive filtered events are not returned. The first value that would be filtered out is returned with its time and the enumeration value \&quot;Filtered\&quot;. The next value in the collection will be the next compressed value in the specified direction that passes the filter criteria - if any. When both boundaryType and a filterExpression are specified, the events returned for the boundary condition specified are passed through the filter. If the includeFilteredValues parameter is true, the boundary values will be reported at the proper timestamps with the enumeration value \&quot;Filtered\&quot; when the filter conditions are not met at the boundary time. If the includeFilteredValues parameter is false for this case, no event is returned for the boundary time.
     * @param webId The ID of the stream.
     * @param boundaryType An optional value that determines how the times and values of the returned end points are determined. The default is &#39;Inside&#39;.
     * @param desiredUnits The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure.
     * @param endTime An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param filterExpression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. The default is no filtering.
     * @param includeFilteredValues Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted.
     * @param maxCount The maximum number of values to be returned. The default is 1000.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param startTime An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamGetRecorded (webId: string, boundaryType?: string, desiredUnits?: string, endTime?: string, filterExpression?: string, includeFilteredValues?: boolean, maxCount?: number, selectedFields?: string, startTime?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: TimedValues;  }> {
        const localVarPath = this.basePath + '/streams/{webId}/recorded'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamGetRecorded.');
        }

        if (boundaryType !== undefined) {
            queryParameters['boundaryType'] = boundaryType;
        }

        if (desiredUnits !== undefined) {
            queryParameters['desiredUnits'] = desiredUnits;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (filterExpression !== undefined) {
            queryParameters['filterExpression'] = filterExpression;
        }

        if (includeFilteredValues !== undefined) {
            queryParameters['includeFilteredValues'] = includeFilteredValues;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimedValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a single recorded value based on the passed time and retrieval mode from the stream.
     * 
     * @param webId The ID of the stream.
     * @param time The timestamp at which the value is desired.
     * @param desiredUnits The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure.
     * @param retrievalMode An optional value that determines the value to return when a value doesn&#39;t exist at the exact time specified. The default is &#39;Auto&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamGetRecordedAtTime (webId: string, time: string, desiredUnits?: string, retrievalMode?: string, selectedFields?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: TimedValue;  }> {
        const localVarPath = this.basePath + '/streams/{webId}/recordedattime'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamGetRecordedAtTime.');
        }

        // verify required parameter 'time' is not null or undefined
        if (time === null || time === undefined) {
            throw new Error('Required parameter time was null or undefined when calling streamGetRecordedAtTime.');
        }

        if (time !== undefined) {
            queryParameters['time'] = time;
        }

        if (desiredUnits !== undefined) {
            queryParameters['desiredUnits'] = desiredUnits;
        }

        if (retrievalMode !== undefined) {
            queryParameters['retrievalMode'] = retrievalMode;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimedValue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieves recorded values at the specified times.
     * 
     * @param webId The ID of the stream.
     * @param desiredUnits The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure.
     * @param retrievalMode An optional value that determines the value to return when a value doesn&#39;t exist at the exact time specified. The default is &#39;Auto&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param time The timestamp at which to retrieve a recorded value. Multiple timestamps may be specified with multiple instances of the parameter.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamGetRecordedAtTimes (webId: string, desiredUnits?: string, retrievalMode?: string, selectedFields?: string, sortOrder?: string, time?: Array<string>, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: TimedValues;  }> {
        const localVarPath = this.basePath + '/streams/{webId}/recordedattimes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamGetRecordedAtTimes.');
        }

        if (desiredUnits !== undefined) {
            queryParameters['desiredUnits'] = desiredUnits;
        }

        if (retrievalMode !== undefined) {
            queryParameters['retrievalMode'] = retrievalMode;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (time !== undefined) {
            queryParameters['time'] = time;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimedValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a summary over the specified time range for the stream.
     * Count is the only summary type supported on non-numeric streams. Requesting a summary for any other type will generate an error. Time-weighted totals are computed by integrating the rate tag values over the requested time range. If some of the data are bad in the time range, the calculated total is divided by the fraction of the time period for which there are good values. This approach is equivalent to assuming that during the period of bad data, the tag takes on the average values for the entire calculation time range. The PercentGood summary may be used to determine if the calculation results are suitable for the application&#39;s purposes. For time-weighted totals, if the time unit rate of the stream cannot be determined, then the value will be totaled assuming a unit of \&quot;per day\&quot; and no unit of measure will be assigned to the value. If the measured time component of the tag is not based on a day, the user of the data must convert the totalized value to the correct units.
     * @param webId The ID of the stream.
     * @param calculationBasis Specifies the method of evaluating the data over the time range. The default is &#39;TimeWeighted&#39;.
     * @param endTime An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param filterExpression A string containing a filter expression. Expression variables are relative to the attribute. Use &#39;.&#39; to reference the containing attribute.
     * @param sampleInterval When the sampleType is Interval, sampleInterval specifies how often the filter expression is evaluated when computing the summary for an interval.
     * @param sampleType Defines the evaluation of an expression over a time range. The default is &#39;ExpressionRecordedValues&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param startTime An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set.
     * @param summaryDuration The duration of each summary interval. If specified in hours, minutes, seconds, or milliseconds, the summary durations will be evenly spaced UTC time intervals. Longer interval types are interpreted using wall clock rules and are time zone dependent.
     * @param summaryType Specifies the kinds of summaries to produce over the range. The default is &#39;Total&#39;. Multiple summary types may be specified by using multiple instances of summaryType.
     * @param timeType Specifies how to calculate the timestamp for each interval. The default is &#39;Auto&#39;.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamGetSummary (webId: string, calculationBasis?: string, endTime?: string, filterExpression?: string, sampleInterval?: string, sampleType?: string, selectedFields?: string, startTime?: string, summaryDuration?: string, summaryType?: Array<string>, timeType?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSummaryValue;  }> {
        const localVarPath = this.basePath + '/streams/{webId}/summary'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamGetSummary.');
        }

        if (calculationBasis !== undefined) {
            queryParameters['calculationBasis'] = calculationBasis;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (filterExpression !== undefined) {
            queryParameters['filterExpression'] = filterExpression;
        }

        if (sampleInterval !== undefined) {
            queryParameters['sampleInterval'] = sampleInterval;
        }

        if (sampleType !== undefined) {
            queryParameters['sampleType'] = sampleType;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (summaryDuration !== undefined) {
            queryParameters['summaryDuration'] = summaryDuration;
        }

        if (summaryType !== undefined) {
            queryParameters['summaryType'] = summaryType;
        }

        if (timeType !== undefined) {
            queryParameters['timeType'] = timeType;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSummaryValue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the value of the stream at the specified time. By default, this is usually the current value.
     * 
     * @param webId The ID of the stream.
     * @param desiredUnits The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param time An optional time. The default time context is determined from the owning object - for example, the time range of the event frame or transfer which holds this attribute. Otherwise, the implementation of the Data Reference determines the meaning of no context. For Points or simply configured PI Point Data References, this means the snapshot value of the PI Point on the Data Server.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamGetValue (webId: string, desiredUnits?: string, selectedFields?: string, time?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: TimedValue;  }> {
        const localVarPath = this.basePath + '/streams/{webId}/value'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamGetValue.');
        }

        if (desiredUnits !== undefined) {
            queryParameters['desiredUnits'] = desiredUnits;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (time !== undefined) {
            queryParameters['time'] = time;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimedValue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a value for the specified stream.
     * 
     * @param webId The ID of the stream.
     * @param value The value to add or update.
     * @param bufferOption The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;.
     * @param updateOption The desired AFUpdateOption. The default is &#39;Replace&#39;. This parameter is ignored if the attribute is a configuration item.
     */
    public streamUpdateValue (webId: string, value: TimedValue, bufferOption?: string, updateOption?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/streams/{webId}/value'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamUpdateValue.');
        }

        // verify required parameter 'value' is not null or undefined
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling streamUpdateValue.');
        }

        if (bufferOption !== undefined) {
            queryParameters['bufferOption'] = bufferOption;
        }

        if (updateOption !== undefined) {
            queryParameters['updateOption'] = updateOption;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: value,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates multiple values for the specified stream.
     * 
     * @param webId The ID of the stream.
     * @param values The values to add or update.
     * @param bufferOption The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;.
     * @param updateOption The desired AFUpdateOption. The default is &#39;Replace&#39;.
     */
    public streamUpdateValues (webId: string, values: Array<TimedValue>, bufferOption?: string, updateOption?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSubstatus;  }> {
        const localVarPath = this.basePath + '/streams/{webId}/recorded'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamUpdateValues.');
        }

        // verify required parameter 'values' is not null or undefined
        if (values === null || values === undefined) {
            throw new Error('Required parameter values was null or undefined when calling streamUpdateValues.');
        }

        if (bufferOption !== undefined) {
            queryParameters['bufferOption'] = bufferOption;
        }

        if (updateOption !== undefined) {
            queryParameters['updateOption'] = updateOption;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: values,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSubstatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StreamSetApiApiKeys {
}

export class StreamSetApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: StreamSetApiApiKeys, value: string) {
        this.authentications[StreamSetApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Opens a channel that will send messages about any value changes for the attributes of an Element, Event Frame, or Attribute.
     * 
     * @param webId The ID of an Element, Event Frame or Attribute, which is the base element or parent of all the stream attributes.
     * @param categoryName Specify that included attributes must have this category. The default is no category filter.
     * @param includeInitialValues Specified if the channel should send a message with the current values of all the streams after the connection is opened. The default is &#39;false&#39;.
     * @param nameFilter The name query string used for filtering attributes. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;.
     * @param showExcluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;.
     * @param showHidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;.
     * @param templateName Specify that included attributes must be members of this template. The default is no template filter.
     */
    public streamSetGetChannel (webId: string, categoryName?: string, includeInitialValues?: boolean, nameFilter?: string, searchFullHierarchy?: boolean, showExcluded?: boolean, showHidden?: boolean, templateName?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/streamsets/{webId}/channel'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetChannel.');
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (includeInitialValues !== undefined) {
            queryParameters['includeInitialValues'] = includeInitialValues;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (showExcluded !== undefined) {
            queryParameters['showExcluded'] = showExcluded;
        }

        if (showHidden !== undefined) {
            queryParameters['showHidden'] = showHidden;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Opens a channel that will send messages about any value changes for the specified streams.
     * 
     * @param webId The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter.
     * @param includeInitialValues Specified if the channel should send a message with the current values of all the streams after the connection is opened. The default is &#39;false&#39;.
     */
    public streamSetGetChannelAdHoc (webId: Array<string>, includeInitialValues?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/streamsets/channel';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetChannelAdHoc.');
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        if (includeInitialValues !== undefined) {
            queryParameters['includeInitialValues'] = includeInitialValues;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns End of stream values of the attributes for an Element, Event Frame or Attribute
     * 
     * @param webId The ID of an Element, Event Frame or Attribute, which is the base element or parent of all the stream attributes.
     * @param categoryName Specify that included attributes must have this category. The default is no category filter.
     * @param nameFilter The name query string used for filtering attributes. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param showExcluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;.
     * @param showHidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;.
     * @param templateName Specify that included attributes must be members of this template. The default is no template filter.
     */
    public streamSetGetEnd (webId: string, categoryName?: string, nameFilter?: string, searchFullHierarchy?: boolean, selectedFields?: string, showExcluded?: boolean, showHidden?: boolean, templateName?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValue;  }> {
        const localVarPath = this.basePath + '/streamsets/{webId}/end'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetEnd.');
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (showExcluded !== undefined) {
            queryParameters['showExcluded'] = showExcluded;
        }

        if (showHidden !== undefined) {
            queryParameters['showHidden'] = showHidden;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns End Of Stream values for attributes of the specified streams
     * 
     * @param webId The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public streamSetGetEndAdHoc (webId: Array<string>, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }> {
        const localVarPath = this.basePath + '/streamsets/end';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetEndAdHoc.');
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns interpolated values of attributes for an element, event frame or attribute over the specified time range at the specified sampling interval.
     * 
     * @param webId The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes.
     * @param categoryName Specify that included attributes must have this category. The default is no category filter.
     * @param endTime An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param filterExpression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering.
     * @param includeFilteredValues Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted.
     * @param interval The sampling interval, in AFTimeSpan format.
     * @param nameFilter The name query string used for filtering attributes. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param showExcluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;.
     * @param showHidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;.
     * @param startTime An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set.
     * @param templateName Specify that included attributes must be members of this template. The default is no template filter.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetInterpolated (webId: string, categoryName?: string, endTime?: string, filterExpression?: string, includeFilteredValues?: boolean, interval?: string, nameFilter?: string, searchFullHierarchy?: boolean, selectedFields?: string, showExcluded?: boolean, showHidden?: boolean, startTime?: string, templateName?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }> {
        const localVarPath = this.basePath + '/streamsets/{webId}/interpolated'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetInterpolated.');
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (filterExpression !== undefined) {
            queryParameters['filterExpression'] = filterExpression;
        }

        if (includeFilteredValues !== undefined) {
            queryParameters['includeFilteredValues'] = includeFilteredValues;
        }

        if (interval !== undefined) {
            queryParameters['interval'] = interval;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (showExcluded !== undefined) {
            queryParameters['showExcluded'] = showExcluded;
        }

        if (showHidden !== undefined) {
            queryParameters['showHidden'] = showHidden;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns interpolated values of the specified streams over the specified time range at the specified sampling interval.
     * 
     * @param webId The ID of a stream. Multiple streams may be specified with multiple instances of the parameter.
     * @param endTime An optional end time. The default is &#39;*&#39;. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param filterExpression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering.
     * @param includeFilteredValues Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted.
     * @param interval The sampling interval, in AFTimeSpan format.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param startTime An optional start time. The default is &#39;*-1d&#39;.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetInterpolatedAdHoc (webId: Array<string>, endTime?: string, filterExpression?: string, includeFilteredValues?: boolean, interval?: string, selectedFields?: string, startTime?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }> {
        const localVarPath = this.basePath + '/streamsets/interpolated';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetInterpolatedAdHoc.');
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (filterExpression !== undefined) {
            queryParameters['filterExpression'] = filterExpression;
        }

        if (includeFilteredValues !== undefined) {
            queryParameters['includeFilteredValues'] = includeFilteredValues;
        }

        if (interval !== undefined) {
            queryParameters['interval'] = interval;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns interpolated values of attributes for an element, event frame or attribute at the specified times.
     * 
     * @param webId The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes.
     * @param time The timestamp at which to retrieve a interpolated value. Multiple timestamps may be specified with multiple instances of the parameter.
     * @param categoryName Specify that included attributes must have this category. The default is no category filter.
     * @param filterExpression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering.
     * @param includeFilteredValues Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted.
     * @param nameFilter The name query string used for filtering attributes. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param showExcluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;.
     * @param showHidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param templateName Specify that included attributes must be members of this template. The default is no template filter.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetInterpolatedAtTimes (webId: string, time: Array<string>, categoryName?: string, filterExpression?: string, includeFilteredValues?: boolean, nameFilter?: string, searchFullHierarchy?: boolean, selectedFields?: string, showExcluded?: boolean, showHidden?: boolean, sortOrder?: string, templateName?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }> {
        const localVarPath = this.basePath + '/streamsets/{webId}/interpolatedattimes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetInterpolatedAtTimes.');
        }

        // verify required parameter 'time' is not null or undefined
        if (time === null || time === undefined) {
            throw new Error('Required parameter time was null or undefined when calling streamSetGetInterpolatedAtTimes.');
        }

        if (time !== undefined) {
            queryParameters['time'] = time;
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (filterExpression !== undefined) {
            queryParameters['filterExpression'] = filterExpression;
        }

        if (includeFilteredValues !== undefined) {
            queryParameters['includeFilteredValues'] = includeFilteredValues;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (showExcluded !== undefined) {
            queryParameters['showExcluded'] = showExcluded;
        }

        if (showHidden !== undefined) {
            queryParameters['showHidden'] = showHidden;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns interpolated values of the specified streams at the specified times.
     * 
     * @param time The timestamp at which to retrieve a interpolated value. Multiple timestamps may be specified with multiple instances of the parameter.
     * @param webId The ID of a stream. Multiple streams may be specified with multiple instances of the parameter.
     * @param filterExpression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering.
     * @param includeFilteredValues Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetInterpolatedAtTimesAdHoc (time: Array<string>, webId: Array<string>, filterExpression?: string, includeFilteredValues?: boolean, selectedFields?: string, sortOrder?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }> {
        const localVarPath = this.basePath + '/streamsets/interpolatedattimes';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'time' is not null or undefined
        if (time === null || time === undefined) {
            throw new Error('Required parameter time was null or undefined when calling streamSetGetInterpolatedAtTimesAdHoc.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetInterpolatedAtTimesAdHoc.');
        }

        if (time !== undefined) {
            queryParameters['time'] = time;
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        if (filterExpression !== undefined) {
            queryParameters['filterExpression'] = filterExpression;
        }

        if (includeFilteredValues !== undefined) {
            queryParameters['includeFilteredValues'] = includeFilteredValues;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns values of attributes for an element, event frame or attribute over the specified time range suitable for plotting over the number of intervals (typically represents pixels).
     * For each interval, the data available is examined and significant values are returned. Each interval can produce up to 5 values if they are unique, the first value in the interval, the last value, the highest value, the lowest value and at most one exceptional point (bad status or digital state).
     * @param webId The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes.
     * @param categoryName Specify that included attributes must have this category. The default is no category filter.
     * @param endTime An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param intervals The number of intervals to plot over. Typically, this would be the number of horizontal pixels in the trend. The default is &#39;24&#39;. For each interval, the data available is examined and significant values are returned. Each interval can produce up to 5 values if they are unique, the first value in the interval, the last value, the highest value, the lowest value and at most one exceptional point (bad status or digital state).
     * @param nameFilter The name query string used for filtering attributes. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param showExcluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;.
     * @param showHidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;.
     * @param startTime An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set.
     * @param templateName Specify that included attributes must be members of this template. The default is no template filter.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetPlot (webId: string, categoryName?: string, endTime?: string, intervals?: number, nameFilter?: string, searchFullHierarchy?: boolean, selectedFields?: string, showExcluded?: boolean, showHidden?: boolean, startTime?: string, templateName?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }> {
        const localVarPath = this.basePath + '/streamsets/{webId}/plot'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetPlot.');
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (intervals !== undefined) {
            queryParameters['intervals'] = intervals;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (showExcluded !== undefined) {
            queryParameters['showExcluded'] = showExcluded;
        }

        if (showHidden !== undefined) {
            queryParameters['showHidden'] = showHidden;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns values of attributes for the specified streams over the specified time range suitable for plotting over the number of intervals (typically represents pixels).
     * For each interval, the data available is examined and significant values are returned. Each interval can produce up to 5 values if they are unique, the first value in the interval, the last value, the highest value, the lowest value and at most one exceptional point (bad status or digital state).
     * @param webId The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter.
     * @param endTime An optional end time. The default is &#39;*&#39;. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param intervals The number of intervals to plot over. Typically, this would be the number of horizontal pixels in the trend. The default is &#39;24&#39;. For each interval, the data available is examined and significant values are returned. Each interval can produce up to 5 values if they are unique, the first value in the interval, the last value, the highest value, the lowest value and at most one exceptional point (bad status or digital state).
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param startTime An optional start time. The default is &#39;*-1d&#39;.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetPlotAdHoc (webId: Array<string>, endTime?: string, intervals?: number, selectedFields?: string, startTime?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }> {
        const localVarPath = this.basePath + '/streamsets/plot';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetPlotAdHoc.');
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (intervals !== undefined) {
            queryParameters['intervals'] = intervals;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns recorded values of the attributes for an element, event frame, or attribute.
     * 
     * @param webId The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes.
     * @param boundaryType An optional value that determines how the times and values of the returned end points are determined. The default is &#39;Inside&#39;.
     * @param categoryName Specify that included attributes must have this category. The default is no category filter.
     * @param endTime An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param filterExpression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. The default is no filtering.
     * @param includeFilteredValues Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted.
     * @param maxCount The maximum number of values to be returned. The default is 1000.
     * @param nameFilter The name query string used for filtering attributes. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param showExcluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;.
     * @param showHidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;.
     * @param startTime An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set.
     * @param templateName Specify that included attributes must be members of this template. The default is no template filter.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetRecorded (webId: string, boundaryType?: string, categoryName?: string, endTime?: string, filterExpression?: string, includeFilteredValues?: boolean, maxCount?: number, nameFilter?: string, searchFullHierarchy?: boolean, selectedFields?: string, showExcluded?: boolean, showHidden?: boolean, startTime?: string, templateName?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }> {
        const localVarPath = this.basePath + '/streamsets/{webId}/recorded'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetRecorded.');
        }

        if (boundaryType !== undefined) {
            queryParameters['boundaryType'] = boundaryType;
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (filterExpression !== undefined) {
            queryParameters['filterExpression'] = filterExpression;
        }

        if (includeFilteredValues !== undefined) {
            queryParameters['includeFilteredValues'] = includeFilteredValues;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (showExcluded !== undefined) {
            queryParameters['showExcluded'] = showExcluded;
        }

        if (showHidden !== undefined) {
            queryParameters['showHidden'] = showHidden;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns recorded values of the specified streams.
     * 
     * @param webId The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter.
     * @param boundaryType An optional value that determines how the times and values of the returned end points are determined. The default is &#39;Inside&#39;.
     * @param endTime An optional end time. The default is &#39;*&#39;. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param filterExpression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. The default is no filtering.
     * @param includeFilteredValues Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted.
     * @param maxCount The maximum number of values to be returned. The default is 1000.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param startTime An optional start time. The default is &#39;*-1d&#39;.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetRecordedAdHoc (webId: Array<string>, boundaryType?: string, endTime?: string, filterExpression?: string, includeFilteredValues?: boolean, maxCount?: number, selectedFields?: string, startTime?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }> {
        const localVarPath = this.basePath + '/streamsets/recorded';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetRecordedAdHoc.');
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        if (boundaryType !== undefined) {
            queryParameters['boundaryType'] = boundaryType;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (filterExpression !== undefined) {
            queryParameters['filterExpression'] = filterExpression;
        }

        if (includeFilteredValues !== undefined) {
            queryParameters['includeFilteredValues'] = includeFilteredValues;
        }

        if (maxCount !== undefined) {
            queryParameters['maxCount'] = maxCount;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns recorded values of the attributes for an element, event frame, or attribute.
     * 
     * @param webId The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes.
     * @param time The timestamp at which the values are desired.
     * @param categoryName Specify that included attributes must have this category. The default is no category filter.
     * @param nameFilter The name query string used for filtering attributes. The default is no filter.
     * @param retrievalMode An optional value that determines the values to return when values don&#39;t exist at the exact time specified. The default is &#39;Auto&#39;.
     * @param searchFullHierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param showExcluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;.
     * @param showHidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;.
     * @param templateName Specify that included attributes must be members of this template. The default is no template filter.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetRecordedAtTime (webId: string, time: string, categoryName?: string, nameFilter?: string, retrievalMode?: string, searchFullHierarchy?: boolean, selectedFields?: string, showExcluded?: boolean, showHidden?: boolean, templateName?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }> {
        const localVarPath = this.basePath + '/streamsets/{webId}/recordedattime'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetRecordedAtTime.');
        }

        // verify required parameter 'time' is not null or undefined
        if (time === null || time === undefined) {
            throw new Error('Required parameter time was null or undefined when calling streamSetGetRecordedAtTime.');
        }

        if (time !== undefined) {
            queryParameters['time'] = time;
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (retrievalMode !== undefined) {
            queryParameters['retrievalMode'] = retrievalMode;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (showExcluded !== undefined) {
            queryParameters['showExcluded'] = showExcluded;
        }

        if (showHidden !== undefined) {
            queryParameters['showHidden'] = showHidden;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns recorded values based on the passed time and retrieval mode.
     * 
     * @param time The timestamp at which the values are desired.
     * @param webId The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter.
     * @param retrievalMode An optional value that determines the values to return when values don&#39;t exist at the exact time specified. The default is &#39;Auto&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetRecordedAtTimeAdHoc (time: string, webId: Array<string>, retrievalMode?: string, selectedFields?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValue;  }> {
        const localVarPath = this.basePath + '/streamsets/recordedattime';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'time' is not null or undefined
        if (time === null || time === undefined) {
            throw new Error('Required parameter time was null or undefined when calling streamSetGetRecordedAtTimeAdHoc.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetRecordedAtTimeAdHoc.');
        }

        if (time !== undefined) {
            queryParameters['time'] = time;
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        if (retrievalMode !== undefined) {
            queryParameters['retrievalMode'] = retrievalMode;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns recorded values of attributes for an element, event frame or attribute at the specified times.
     * 
     * @param webId The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes.
     * @param time The timestamp at which to retrieve a recorded value. Multiple timestamps may be specified with multiple instances of the parameter.
     * @param categoryName Specify that included attributes must have this category. The default is no category filter.
     * @param nameFilter The name query string used for filtering attributes. The default is no filter.
     * @param retrievalMode An optional value that determines the values to return when values don&#39;t exist at the exact time specified. The default is &#39;Auto&#39;.
     * @param searchFullHierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param showExcluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;.
     * @param showHidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param templateName Specify that included attributes must be members of this template. The default is no template filter.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetRecordedAtTimes (webId: string, time: Array<string>, categoryName?: string, nameFilter?: string, retrievalMode?: string, searchFullHierarchy?: boolean, selectedFields?: string, showExcluded?: boolean, showHidden?: boolean, sortOrder?: string, templateName?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }> {
        const localVarPath = this.basePath + '/streamsets/{webId}/recordedattimes'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetRecordedAtTimes.');
        }

        // verify required parameter 'time' is not null or undefined
        if (time === null || time === undefined) {
            throw new Error('Required parameter time was null or undefined when calling streamSetGetRecordedAtTimes.');
        }

        if (time !== undefined) {
            queryParameters['time'] = time;
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (retrievalMode !== undefined) {
            queryParameters['retrievalMode'] = retrievalMode;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (showExcluded !== undefined) {
            queryParameters['showExcluded'] = showExcluded;
        }

        if (showHidden !== undefined) {
            queryParameters['showHidden'] = showHidden;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns recorded values of the specified streams at the specified times.
     * 
     * @param time The timestamp at which to retrieve a recorded value. Multiple timestamps may be specified with multiple instances of the parameter.
     * @param webId The ID of a stream. Multiple streams may be specified with multiple instances of the parameter.
     * @param retrievalMode An optional value that determines the values to return when values don&#39;t exist at the exact time specified. The default is &#39;Auto&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param sortOrder The order that the returned collection is sorted. The default is &#39;Ascending&#39;.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetRecordedAtTimesAdHoc (time: Array<string>, webId: Array<string>, retrievalMode?: string, selectedFields?: string, sortOrder?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }> {
        const localVarPath = this.basePath + '/streamsets/recordedattimes';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'time' is not null or undefined
        if (time === null || time === undefined) {
            throw new Error('Required parameter time was null or undefined when calling streamSetGetRecordedAtTimesAdHoc.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetRecordedAtTimesAdHoc.');
        }

        if (time !== undefined) {
            queryParameters['time'] = time;
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        if (retrievalMode !== undefined) {
            queryParameters['retrievalMode'] = retrievalMode;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (sortOrder !== undefined) {
            queryParameters['sortOrder'] = sortOrder;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValues;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns summary values of the attributes for an element, event frame or attribute.
     * 
     * @param webId The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes.
     * @param calculationBasis Specifies the method of evaluating the data over the time range. The default is &#39;TimeWeighted&#39;.
     * @param categoryName Specify that included attributes must have this category. The default is no category filter.
     * @param endTime An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param filterExpression A string containing a filter expression. Expression variables are relative to the attribute. Use &#39;.&#39; to reference the containing attribute. The default is no filtering.
     * @param nameFilter The name query string used for filtering attributes. The default is no filter.
     * @param sampleInterval A time span specifies how often the filter expression is evaluated when computing the summary for an interval, if the sampleType is &#39;Interval&#39;.
     * @param sampleType A flag which specifies one or more summaries to compute for each interval over the time range. The default is &#39;ExpressionRecordedValues&#39;.
     * @param searchFullHierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param showExcluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;.
     * @param showHidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;.
     * @param startTime An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set.
     * @param summaryDuration The duration of each summary interval.
     * @param summaryType Specifies the kinds of summaries to produce over the range. The default is &#39;Total&#39;. Multiple summary types may be specified by using multiple instances of summaryType.
     * @param templateName Specify that included attributes must be members of this template. The default is no template filter.
     * @param timeType Specifies how to calculate the timestamp for each interval. The default is &#39;Auto&#39;.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetSummaries (webId: string, calculationBasis?: string, categoryName?: string, endTime?: string, filterExpression?: string, nameFilter?: string, sampleInterval?: string, sampleType?: string, searchFullHierarchy?: boolean, selectedFields?: string, showExcluded?: boolean, showHidden?: boolean, startTime?: string, summaryDuration?: string, summaryType?: Array<string>, templateName?: string, timeType?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamSummaries;  }> {
        const localVarPath = this.basePath + '/streamsets/{webId}/summary'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetSummaries.');
        }

        if (calculationBasis !== undefined) {
            queryParameters['calculationBasis'] = calculationBasis;
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (filterExpression !== undefined) {
            queryParameters['filterExpression'] = filterExpression;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (sampleInterval !== undefined) {
            queryParameters['sampleInterval'] = sampleInterval;
        }

        if (sampleType !== undefined) {
            queryParameters['sampleType'] = sampleType;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (showExcluded !== undefined) {
            queryParameters['showExcluded'] = showExcluded;
        }

        if (showHidden !== undefined) {
            queryParameters['showHidden'] = showHidden;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (summaryDuration !== undefined) {
            queryParameters['summaryDuration'] = summaryDuration;
        }

        if (summaryType !== undefined) {
            queryParameters['summaryType'] = summaryType;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        if (timeType !== undefined) {
            queryParameters['timeType'] = timeType;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamSummaries;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns summary values of the specified streams.
     * 
     * @param webId The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter.
     * @param calculationBasis Specifies the method of evaluating the data over the time range. The default is &#39;TimeWeighted&#39;.
     * @param endTime An optional end time. The default is &#39;*&#39;. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order.
     * @param filterExpression A string containing a filter expression. Expression variables are relative to the attribute. Use &#39;.&#39; to reference the containing attribute. The default is no filtering.
     * @param sampleInterval A time span specifies how often the filter expression is evaluated when computing the summary for an interval, if the sampleType is &#39;Interval&#39;.
     * @param sampleType A flag which specifies one or more summaries to compute for each interval over the time range. The default is &#39;ExpressionRecordedValues&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param startTime An optional start time. The default is &#39;*-1d&#39;.
     * @param summaryDuration The duration of each summary interval.
     * @param summaryType Specifies the kinds of summaries to produce over the range. The default is &#39;Total&#39;. Multiple summary types may be specified by using multiple instances of summaryType.
     * @param timeType Specifies how to calculate the timestamp for each interval. The default is &#39;Auto&#39;.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetSummariesAdHoc (webId: Array<string>, calculationBasis?: string, endTime?: string, filterExpression?: string, sampleInterval?: string, sampleType?: string, selectedFields?: string, startTime?: string, summaryDuration?: string, summaryType?: Array<string>, timeType?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamSummaries;  }> {
        const localVarPath = this.basePath + '/streamsets/summary';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetSummariesAdHoc.');
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        if (calculationBasis !== undefined) {
            queryParameters['calculationBasis'] = calculationBasis;
        }

        if (endTime !== undefined) {
            queryParameters['endTime'] = endTime;
        }

        if (filterExpression !== undefined) {
            queryParameters['filterExpression'] = filterExpression;
        }

        if (sampleInterval !== undefined) {
            queryParameters['sampleInterval'] = sampleInterval;
        }

        if (sampleType !== undefined) {
            queryParameters['sampleType'] = sampleType;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (startTime !== undefined) {
            queryParameters['startTime'] = startTime;
        }

        if (summaryDuration !== undefined) {
            queryParameters['summaryDuration'] = summaryDuration;
        }

        if (summaryType !== undefined) {
            queryParameters['summaryType'] = summaryType;
        }

        if (timeType !== undefined) {
            queryParameters['timeType'] = timeType;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamSummaries;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns values of the attributes for an Element, Event Frame or Attribute at the specified time.
     * 
     * @param webId The ID of an Element, Event Frame or Attribute, which is the base element or parent of all the stream attributes.
     * @param categoryName Specify that included attributes must have this category. The default is no category filter.
     * @param nameFilter The name query string used for filtering attributes. The default is no filter.
     * @param searchFullHierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param showExcluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;.
     * @param showHidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;.
     * @param templateName Specify that included attributes must be members of this template. The default is no template filter.
     * @param time An AF time string, which is used as the time context to get stream values if it is provided. By default, it is not specified, and the default time context of the AF object will be used.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetValues (webId: string, categoryName?: string, nameFilter?: string, searchFullHierarchy?: boolean, selectedFields?: string, showExcluded?: boolean, showHidden?: boolean, templateName?: string, time?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValue;  }> {
        const localVarPath = this.basePath + '/streamsets/{webId}/value'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetValues.');
        }

        if (categoryName !== undefined) {
            queryParameters['categoryName'] = categoryName;
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (searchFullHierarchy !== undefined) {
            queryParameters['searchFullHierarchy'] = searchFullHierarchy;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (showExcluded !== undefined) {
            queryParameters['showExcluded'] = showExcluded;
        }

        if (showHidden !== undefined) {
            queryParameters['showHidden'] = showHidden;
        }

        if (templateName !== undefined) {
            queryParameters['templateName'] = templateName;
        }

        if (time !== undefined) {
            queryParameters['time'] = time;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns values of the specified streams.
     * 
     * @param webId The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     * @param time An AF time string, which is used as the time context to get stream values if it is provided. By default, it is not specified, and the default time context of the AF object will be used.
     * @param timeZone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used.
     */
    public streamSetGetValuesAdHoc (webId: Array<string>, selectedFields?: string, time?: string, timeZone?: string) : Promise<{ response: http.IncomingMessage; body: ItemsStreamValue;  }> {
        const localVarPath = this.basePath + '/streamsets/value';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetGetValuesAdHoc.');
        }

        if (webId !== undefined) {
            queryParameters['webId'] = webId;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        if (time !== undefined) {
            queryParameters['time'] = time;
        }

        if (timeZone !== undefined) {
            queryParameters['timeZone'] = timeZone;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsStreamValue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a single value for the specified streams.
     * 
     * @param webId The ID of the parent element, event frame, or attribute. Attributes specified in the body must be descendants of the specified object.
     * @param values The values to add or update.
     * @param bufferOption The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;.
     * @param updateOption The desired AFUpdateOption. The default is &#39;Replace&#39;.
     */
    public streamSetUpdateValue (webId: string, values: Array<StreamValue>, bufferOption?: string, updateOption?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSubstatus;  }> {
        const localVarPath = this.basePath + '/streamsets/{webId}/value'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetUpdateValue.');
        }

        // verify required parameter 'values' is not null or undefined
        if (values === null || values === undefined) {
            throw new Error('Required parameter values was null or undefined when calling streamSetUpdateValue.');
        }

        if (bufferOption !== undefined) {
            queryParameters['bufferOption'] = bufferOption;
        }

        if (updateOption !== undefined) {
            queryParameters['updateOption'] = updateOption;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: values,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSubstatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates a single value for the specified streams.
     * 
     * @param values The values to add or update.
     * @param bufferOption The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;.
     * @param updateOption The desired AFUpdateOption. The default is &#39;Replace&#39;.
     */
    public streamSetUpdateValueAdHoc (values: Array<StreamValues>, bufferOption?: string, updateOption?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSubstatus;  }> {
        const localVarPath = this.basePath + '/streamsets/value';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'values' is not null or undefined
        if (values === null || values === undefined) {
            throw new Error('Required parameter values was null or undefined when calling streamSetUpdateValueAdHoc.');
        }

        if (bufferOption !== undefined) {
            queryParameters['bufferOption'] = bufferOption;
        }

        if (updateOption !== undefined) {
            queryParameters['updateOption'] = updateOption;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: values,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSubstatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates multiple values for the specified streams.
     * 
     * @param webId The ID of the parent element, event frame, or attribute. Attributes specified in the body must be descendants of the specified object.
     * @param values The values to add or update.
     * @param bufferOption The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;.
     * @param updateOption The desired AFUpdateOption. The default is &#39;Replace&#39;.
     */
    public streamSetUpdateValues (webId: string, values: Array<StreamValues>, bufferOption?: string, updateOption?: string) : Promise<{ response: http.IncomingMessage; body: ItemsItemsSubstatus;  }> {
        const localVarPath = this.basePath + '/streamsets/{webId}/recorded'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling streamSetUpdateValues.');
        }

        // verify required parameter 'values' is not null or undefined
        if (values === null || values === undefined) {
            throw new Error('Required parameter values was null or undefined when calling streamSetUpdateValues.');
        }

        if (bufferOption !== undefined) {
            queryParameters['bufferOption'] = bufferOption;
        }

        if (updateOption !== undefined) {
            queryParameters['updateOption'] = updateOption;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: values,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsItemsSubstatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates multiple values for the specified streams.
     * 
     * @param values The values to add or update.
     * @param bufferOption The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;.
     * @param updateOption The desired AFUpdateOption. The default is &#39;Replace&#39;.
     */
    public streamSetUpdateValuesAdHoc (values: Array<StreamValues>, bufferOption?: string, updateOption?: string) : Promise<{ response: http.IncomingMessage; body: ItemsItemsSubstatus;  }> {
        const localVarPath = this.basePath + '/streamsets/recorded';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'values' is not null or undefined
        if (values === null || values === undefined) {
            throw new Error('Required parameter values was null or undefined when calling streamSetUpdateValuesAdHoc.');
        }

        if (bufferOption !== undefined) {
            queryParameters['bufferOption'] = bufferOption;
        }

        if (updateOption !== undefined) {
            queryParameters['updateOption'] = updateOption;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: values,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsItemsSubstatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SystemApiApiKeys {
}

export class SystemApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: SystemApiApiKeys, value: string) {
        this.authentications[SystemApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Get AF cache instances currently in use by the system. These are caches from which user requests are serviced. The number of instances depends on the number of users connected to the service, the service&#39;s authentication method, and the cache instance configuration.
     * 
     */
    public systemCacheInstances () : Promise<{ response: http.IncomingMessage; body: ItemsCacheInstance;  }> {
        const localVarPath = this.basePath + '/system/cacheinstances';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsCacheInstance;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get system links for this PI System Web API instance.
     * 
     */
    public systemLanding () : Promise<{ response: http.IncomingMessage; body: SystemLanding;  }> {
        const localVarPath = this.basePath + '/system';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SystemLanding;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the system uptime, the system state and the number of cache instances for this PI System Web API instance.
     * 
     */
    public systemStatus () : Promise<{ response: http.IncomingMessage; body: SystemStatus;  }> {
        const localVarPath = this.basePath + '/system/status';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SystemStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get information about the Windows identity used to fulfill the request. This depends on the service&#39;s authentication method and the credentials passed by the client. The impersonation level of the Windows identity is included.
     * 
     */
    public systemUserInfo () : Promise<{ response: http.IncomingMessage; body: UserInfo;  }> {
        const localVarPath = this.basePath + '/system/userinfo';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserInfo;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the current versions of the PI Web API instance and all external plugins.
     * 
     */
    public systemVersions () : Promise<{ response: http.IncomingMessage; body: { [key: string]: Version; };  }> {
        const localVarPath = this.basePath + '/system/versions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: { [key: string]: Version; };  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TableApiApiKeys {
}

export class TableApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: TableApiApiKeys, value: string) {
        this.authentications[TableApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create a security entry owned by the table.
     * 
     * @param webId The ID of the table where the security entry will be created.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public tableCreateSecurityEntry (webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tables/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableCreateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling tableCreateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a table.
     * 
     * @param webId The ID of the table to delete.
     */
    public tableDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tables/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a security entry owned by the table.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the table where the security entry will be deleted.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public tableDeleteSecurityEntry (name: string, webId: string, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tables/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling tableDeleteSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableDeleteSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a table.
     * 
     * @param webId The ID of the table.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public tableGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Table;  }> {
        const localVarPath = this.basePath + '/tables/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Table;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a table by path.
     * 
     * @param path The path to the table.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public tableGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Table;  }> {
        const localVarPath = this.basePath + '/tables';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling tableGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Table;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a table&#39;s categories.
     * 
     * @param webId The ID of the table.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public tableGetCategories (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsTableCategory;  }> {
        const localVarPath = this.basePath + '/tables/{webId}/categories'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableGetCategories.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsTableCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the table&#39;s data.
     * 
     * @param webId The ID of the table.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public tableGetData (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tables/{webId}/data'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableGetData.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the table for a specified user.
     * 
     * @param webId The ID of the table for the security to be checked.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public tableGetSecurity (webId: string, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/tables/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling tableGetSecurity.');
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries associated with the table based on the specified criteria. By default, all security entries for this table are returned.
     * 
     * @param webId The ID of the table.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public tableGetSecurityEntries (webId: string, nameFilter?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/tables/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry associated with the table with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the table.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public tableGetSecurityEntryByName (name: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }> {
        const localVarPath = this.basePath + '/tables/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling tableGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableGetSecurityEntryByName.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a table by replacing items in its definition.
     * 
     * @param webId The ID of the table to update.
     * @param table A partial table containing the desired changes.
     */
    public tableUpdate (webId: string, table: Table) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tables/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableUpdate.');
        }

        // verify required parameter 'table' is not null or undefined
        if (table === null || table === undefined) {
            throw new Error('Required parameter table was null or undefined when calling tableUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: table,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the table&#39;s data.
     * 
     * @param webId The ID of the table on which to update the data.
     * @param data The new table data definition.
     */
    public tableUpdateData (webId: string, data: TableData) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tables/{webId}/data'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableUpdateData.');
        }

        // verify required parameter 'data' is not null or undefined
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling tableUpdateData.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: data,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security entry owned by the table.
     * 
     * @param name The name of the security entry.
     * @param webId The ID of the table where the security entry will be updated.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public tableUpdateSecurityEntry (name: string, webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tables/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling tableUpdateSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableUpdateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling tableUpdateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TableCategoryApiApiKeys {
}

export class TableCategoryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: TableCategoryApiApiKeys, value: string) {
        this.authentications[TableCategoryApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create a security entry owned by the table category.
     * 
     * @param webId The ID of the table category where the security entry will be created.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public tableCategoryCreateSecurityEntry (webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tablecategories/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableCategoryCreateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling tableCategoryCreateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a table category.
     * 
     * @param webId The ID of the table category to delete.
     */
    public tableCategoryDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tablecategories/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableCategoryDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a security entry owned by the table category.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the table category where the security entry will be deleted.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public tableCategoryDeleteSecurityEntry (name: string, webId: string, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tablecategories/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling tableCategoryDeleteSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableCategoryDeleteSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a table category.
     * 
     * @param webId The id of the table category.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public tableCategoryGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: TableCategory;  }> {
        const localVarPath = this.basePath + '/tablecategories/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableCategoryGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TableCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a table category by path.
     * This method returns a Table Category based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the target table category.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public tableCategoryGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: TableCategory;  }> {
        const localVarPath = this.basePath + '/tablecategories';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling tableCategoryGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TableCategory;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the security information of the specified security item associated with the table category for a specified user.
     * 
     * @param webId The ID of the table category for the security to be checked.
     * @param userIdentity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned.
     * @param forceRefresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public tableCategoryGetSecurity (webId: string, userIdentity: Array<string>, forceRefresh?: boolean, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }> {
        const localVarPath = this.basePath + '/tablecategories/{webId}/security'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableCategoryGetSecurity.');
        }

        // verify required parameter 'userIdentity' is not null or undefined
        if (userIdentity === null || userIdentity === undefined) {
            throw new Error('Required parameter userIdentity was null or undefined when calling tableCategoryGetSecurity.');
        }

        if (userIdentity !== undefined) {
            queryParameters['userIdentity'] = userIdentity;
        }

        if (forceRefresh !== undefined) {
            queryParameters['forceRefresh'] = forceRefresh;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityRights;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entries associated with the table category based on the specified criteria. By default, all security entries for this table category are returned.
     * 
     * @param webId The ID of the table category.
     * @param nameFilter The name query string used for filtering security entries. The default is no filter.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public tableCategoryGetSecurityEntries (webId: string, nameFilter?: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }> {
        const localVarPath = this.basePath + '/tablecategories/{webId}/securityentries'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableCategoryGetSecurityEntries.');
        }

        if (nameFilter !== undefined) {
            queryParameters['nameFilter'] = nameFilter;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemsSecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the security entry associated with the table category with the specified name.
     * 
     * @param name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username.
     * @param webId The ID of the table category.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public tableCategoryGetSecurityEntryByName (name: string, webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }> {
        const localVarPath = this.basePath + '/tablecategories/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling tableCategoryGetSecurityEntryByName.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableCategoryGetSecurityEntryByName.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SecurityEntry;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a table category by replacing items in its definition.
     * 
     * @param webId The ID of the table category to update.
     * @param tableCategory A partial table category containing the desired changes.
     */
    public tableCategoryUpdate (webId: string, tableCategory: TableCategory) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tablecategories/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableCategoryUpdate.');
        }

        // verify required parameter 'tableCategory' is not null or undefined
        if (tableCategory === null || tableCategory === undefined) {
            throw new Error('Required parameter tableCategory was null or undefined when calling tableCategoryUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: tableCategory,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a security entry owned by the table category.
     * 
     * @param name The name of the security entry.
     * @param webId The ID of the table category where the security entry will be updated.
     * @param securityEntry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed.
     * @param applyToChildren If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change.
     */
    public tableCategoryUpdateSecurityEntry (name: string, webId: string, securityEntry: SecurityEntry, applyToChildren?: boolean) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/tablecategories/{webId}/securityentries/{name}'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling tableCategoryUpdateSecurityEntry.');
        }

        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling tableCategoryUpdateSecurityEntry.');
        }

        // verify required parameter 'securityEntry' is not null or undefined
        if (securityEntry === null || securityEntry === undefined) {
            throw new Error('Required parameter securityEntry was null or undefined when calling tableCategoryUpdateSecurityEntry.');
        }

        if (applyToChildren !== undefined) {
            queryParameters['applyToChildren'] = applyToChildren;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: securityEntry,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TimeRuleApiApiKeys {
}

export class TimeRuleApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: TimeRuleApiApiKeys, value: string) {
        this.authentications[TimeRuleApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Delete a Time Rule.
     * 
     * @param webId The ID of the Time Rule.
     */
    public timeRuleDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/timerules/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling timeRuleDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a Time Rule.
     * 
     * @param webId The ID of the Time Rule.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public timeRuleGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: TimeRule;  }> {
        const localVarPath = this.basePath + '/timerules/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling timeRuleGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimeRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a Time Rule by path.
     * This method returns a Time Rule based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the Time Rule.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public timeRuleGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: TimeRule;  }> {
        const localVarPath = this.basePath + '/timerules';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling timeRuleGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimeRule;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a Time Rule by replacing items in its definition.
     * 
     * @param webId The ID of the Time Rule.
     * @param timeRule A partial Time Rule containing the desired changes.
     */
    public timeRuleUpdate (webId: string, timeRule: TimeRule) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/timerules/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling timeRuleUpdate.');
        }

        // verify required parameter 'timeRule' is not null or undefined
        if (timeRule === null || timeRule === undefined) {
            throw new Error('Required parameter timeRule was null or undefined when calling timeRuleUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: timeRule,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TimeRulePlugInApiApiKeys {
}

export class TimeRulePlugInApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: TimeRulePlugInApiApiKeys, value: string) {
        this.authentications[TimeRulePlugInApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Retrieve a Time Rule Plug-in.
     * 
     * @param webId The ID of the Time Rule Plug-in.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public timeRulePlugInGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: TimeRulePlugIn;  }> {
        const localVarPath = this.basePath + '/timeruleplugins/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling timeRulePlugInGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimeRulePlugIn;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a Time Rule Plug-in by path.
     * This method returns a Time Rule Plug-in based on the hierarchical path associated with it, and should be used when a path has been received from a separate part of the PI System for use in the PI Web API. Users should primarily search with the WebID when available.
     * @param path The path to the Time Rule Plug-in.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public timeRulePlugInGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: TimeRulePlugIn;  }> {
        const localVarPath = this.basePath + '/timeruleplugins';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling timeRulePlugInGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TimeRulePlugIn;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UnitApiApiKeys {
}

export class UnitApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: UnitApiApiKeys, value: string) {
        this.authentications[UnitApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Delete a unit.
     * 
     * @param webId The ID of the unit.
     */
    public unitDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/units/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling unitDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a unit.
     * 
     * @param webId The ID of the unit.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public unitGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Unit;  }> {
        const localVarPath = this.basePath + '/units/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling unitGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Unit;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a unit by path.
     * 
     * @param path The path to the unit.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public unitGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Unit;  }> {
        const localVarPath = this.basePath + '/units';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling unitGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Unit;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a unit.
     * 
     * @param webId The ID of the unit.
     * @param unitDTO A partial unit containing the desired changes.
     */
    public unitUpdate (webId: string, unitDTO: Unit) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/units/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling unitUpdate.');
        }

        // verify required parameter 'unitDTO' is not null or undefined
        if (unitDTO === null || unitDTO === undefined) {
            throw new Error('Required parameter unitDTO was null or undefined when calling unitUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: unitDTO,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UnitClassApiApiKeys {
}

export class UnitClassApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications: any = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: UnitClassApiApiKeys, value: string) {
        this.authentications[UnitClassApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }
    /**
     * Create a unit in the specified Unit Class.
     * 
     * @param webId The ID of the server.
     * @param unitDTO The new unit definition.
     */
    public unitClassCreateUnit (webId: string, unitDTO: Unit) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/unitclasses/{webId}/units'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling unitClassCreateUnit.');
        }

        // verify required parameter 'unitDTO' is not null or undefined
        if (unitDTO === null || unitDTO === undefined) {
            throw new Error('Required parameter unitDTO was null or undefined when calling unitClassCreateUnit.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: unitDTO,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a unit class.
     * 
     * @param webId The ID of the unit class.
     */
    public unitClassDelete (webId: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/unitclasses/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling unitClassDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a unit class.
     * 
     * @param webId The ID of the unit class.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public unitClassGet (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: UnitClass;  }> {
        const localVarPath = this.basePath + '/unitclasses/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling unitClassGet.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UnitClass;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a unit class by path.
     * 
     * @param path The path to the unit class.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public unitClassGetByPath (path: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: UnitClass;  }> {
        const localVarPath = this.basePath + '/unitclasses';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling unitClassGetByPath.');
        }

        if (path !== undefined) {
            queryParameters['path'] = path;
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UnitClass;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the canonical unit of a unit class.
     * 
     * @param webId The ID of unit class.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public unitClassGetCanonicalUnit (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Unit;  }> {
        const localVarPath = this.basePath + '/unitclasses/{webId}/canonicalunit'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling unitClassGetCanonicalUnit.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Unit;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all units belonging to the unit class.
     * 
     * @param webId The ID of unit class.
     * @param selectedFields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned.
     */
    public unitClassGetUnits (webId: string, selectedFields?: string) : Promise<{ response: http.IncomingMessage; body: Unit;  }> {
        const localVarPath = this.basePath + '/unitclasses/{webId}/units'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling unitClassGetUnits.');
        }

        if (selectedFields !== undefined) {
            queryParameters['selectedFields'] = selectedFields;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Unit;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a unit class.
     * 
     * @param webId The ID of the unit class.
     * @param unitClassDTO A partial unit class containing the desired changes.
     */
    public unitClassUpdate (webId: string, unitClassDTO: UnitClass) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/unitclasses/{webId}'
            .replace('{' + 'webId' + '}', String(webId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'webId' is not null or undefined
        if (webId === null || webId === undefined) {
            throw new Error('Required parameter webId was null or undefined when calling unitClassUpdate.');
        }

        // verify required parameter 'unitClassDTO' is not null or undefined
        if (unitClassDTO === null || unitClassDTO === undefined) {
            throw new Error('Required parameter unitClassDTO was null or undefined when calling unitClassUpdate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PATCH',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: unitClassDTO,
        };

        this.authentications.basicAuth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
